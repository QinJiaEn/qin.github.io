[{"title":"面试题库","slug":"面试题库","url":"/posts/c5e9cf91/","content":"\n# 面试题小结\n\n### ==和equlas() 的区别\n\n~~~\n基本数据类型：\n\t==比较内容值\n\tequlas()比较的也是内容值\n引用数据类型：\n\t==比较的是地址值\n\tequlas()比较的也是地址值\n\t重写equlas()之后比较的是内容值\n~~~\n\n"},{"title":"JavaSE阶段笔记","slug":"java笔记","url":"/posts/737a1d7/","content":"# 面向对象编程\n\n## 定义类的补充注意事项\n\n```java\njavabean类：\n\t用来描述一类事物的类，在javabean类中，是不写main方法的\n标准的javabean类：\n\t类名需要见名知意\n\t成员变量需要用private修饰\n\t提供至少两个构造方法\n\t\t无参构造\n\t\t带全部参数的构造方法\n\t成员方法\n\t\t提供每一个成员变量对应的setXxx()和getXxx()\n\t\t如果还有其他行为，也需要写上\n\n测试类：\n\t在以前编写main方法的类，我们可以在测试类中创建javabean类的对象进行赋值调用\n\n\t成员变量的完整定义格式：修饰符 数据类型 变量名称 = 初始化值，一般无需定义初始化值，存在默认值\n```\n\n\n\n## 面向对象三大特征（封装   继承    多态）\n\n### 封装\n\n```java\n告诉我们如何正确的设计对象的属性和方法\n对象代表什么，就得封装对应的数据，并提供数据对应的行为\n\t例如：\n\t\t需求：人画圆，请针对这个需求进行面向对象的设计\n```\n\n### 继承\n\n```java\njava中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系。（java只支持单继承，不支持多继承，但是支持多层继承）\n    每一个类都直接或间接的继承Object\n   \n\tpublic class Student extends Person(){}\nStudent称为子类，Person称为父类\n    \n使用继承的好处\n    可以把多个子类重复的代码抽取到父类中，提高了代码的复用性\n    子类可以在父类的基础上，增加其他的共能，是子类更强大。\n    \n什么时候用继承\n    当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码。\n```\n\n### 多态\n\n```\n什么是多态？\n\t同类型的对象，表现出的不同的形态。\n\n多态的表现形式\n\t父类类型 对象名称 = 子类对象;\n\n多态的前提\n\t有继承/实现（接口）关系\n\t有父类引用指向子类对象\n\t有方法重写\n\t\n多态的好处\n\t使用父类型作为参数，可以接收所有的子类对象，体现多态的扩展与便利 \n\t在多态形式下，右边对象可以实现解耦合，便于扩展和维护\n\t\n多态的弊端\n\t不能使用子类独有的方法\n解决方法\n\t转换成真正的子类类型，从而调用子类独有的功能\n\t转换类型与真实对象类型不一致会报错\n\t转换时用instanceof关键字进行判断\n\t\n调用成员变量的特点：\n\t编译看左边，运行也看左边\n调用成员方法的特点：\n\t编译看左边，运行看右边\n```\n\n\n\n## 关键字还有修饰符\n\n### private < 空着不写 < protected < public   \n\n```java\nprivate关键字：\n\t是一个权限修饰符\n\t可以修饰成员（成员变量和成员方法）\n\t被  private  修饰的成员只能在本类中才能访问\n\t针对private   修饰的成员变量，如果要被其他类使用，应该提供相应的操作\n\t\t提供“setXxx(参数)”方法，用于给成员变量赋值，方法用public修饰\n\t\t提供\"getXxx()\"方法，用于获取成员变量的值，方法用public修饰\n\n实际开发中，一般只用private和public\n    成员变量私有\n    方法公开\n```\n\n### this\n\n```java\nthis关键字   （表示当前方法调用者的地址值）\n\t可以区分成员变量(在类中不在方法中的变量)和局部变量(方法中的变量就叫局部变量)\n```\n\n### this和super使用总结\n\n```\n表示当前方法调用者的地址值\n这个this是由虚拟机赋值的 \n\nthis\n\t理解为一个变量，表示当前方法调用者的地址\nsuper\n\t代表父类存储空间\n```\n\n\n\n### static\n\n```\nstatic表示静态，是java中的一个修饰符，可以修饰成员方法和成员变量\n\n被static修饰的成员变量  静态变量\n\t特点：\n\t\t被该类所有的对象共享\n\t\t不属于对象，属于类\n\t\t随着类的加载而加载，优先于对象存在\n\t调用方式：\n\t\t类名调用和对象名调用\n\n被static修饰的成员方法  静态方法\n\t特点：\n\t\t多用在测试类和工具类中\n\t\tjavabean类中很少会用\n\t调用方式：a\n\t\t类名调用和对象名调用\n```\n\n### static注意事项\n\n```\n静态方法中，只能访问静态\n非静态方法可以访问所有\n静态方法中没有this关键字\n```\n\n### final\n\n```\n可修饰  方法  类   变量\n一旦用final修饰\n\t方法\n\t\t该方法是最终方法，不能被重写\n\t类\n\t\t该类值最终类，不能被继承\n\t变量\n\t\t叫做常量，只能被赋值一次\n\t\tfinal修改基本数据类型，记录的值不能发生改变\n\t\tfinal修改引用数据类型，记录的地址值不能发生改变，内部的属性值还是可以改变的\n\t\t\n```\n\n### instanceof\n\n```\ninstanceof   \n\t用来判断对象和类型是否一致     对象   instanceof   类型\n```\n\n\n\n## 构造方法（构造器，构造函数）\n\n```java\n作用：\n\t在创建对象时，虚拟机（jvm）会自动调用构造方法，作用是给成员变量进行赋值的\n\t\t例如：\n\t\t\tpublic class Student{\n\t\t\t\t修饰符     方法名与类名相同  (参数){\n\t\t\t\t\t方法体;\n\t\t\t\t}\n\t\t\t}\n特点：\n\t方法名与类名相同大小写也要一致\n\t没有返回值类型，没有void\n\t没有具体的返回值(不能由return返回具体的数据)\n\n\n注意事项：\n\t构造方法的定义：\n\t\t如果没有定义构造方法，系统将会给出一个默认的无参构造\n\t\t\t无参构造：\n\t\t\t\t在初始化对象的时候，成员变量的数据均采用默认值\n\t\t如果自己给出了构造方法，系统将不会提供默认的构造方法\n\t\t\t有参构造：\n\t\t\t\t在初始化对象的时候，同时可以给成员变量进行赋值\n\t构造方法的重载：\n\t\t带参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这就叫做构造方法的重载\n\t推荐使用方式：\n\t\t无论是否使用，都手动书写无参构造方法，和带全部参数的构造方法\n```\n\n## 一个对象的内存图\n\n![](java笔记/Snipaste_2023-02-19_15-50-31.png)\n\n\n\n## ==号到底比的是什么？\n\n![](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-02-28_20-54-06.png)\n\n\n\n\n\n# String概述\n\n## 创建String对象的两种方式\n\n```java\n1。直接赋值\n\tString name = \"Mq\";\n2.new\n\tpublic String()  //空参构造\n\tpublic String(char[] chs)  //根据字符数组，创建字符串对象\n\tpublic String(byte[] chs)  //根据字节数字，创建字符串对象\n\n```\n\n### 第二种创建方式\n\n![](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-02-28_20-43-55.png)\n\n\n\n## String的一些方法\n\n### 字符串比较\n\n```java\nboolean equals方法(要比较的字符串)   完全一样结果才是true，否则就是false\n\nboolean equalslgnoreCase(要比较的字符串)  忽略大小写比较   //一般都是字符串\n    \n//比较两个字符串字母的大小\ncompareTo(String str)\n    String s1 = \"a\";\n\tString s2 = \"b\";\n\ts1.compareTo(s2);\t//会返回-1\n```\n\n### 遍历字符串\n\n```java\npublic char charAt(int index): 根据索引返回字符\npublic int length(): 返回此字符串的长度\n数组的长度： 数组名.length\n字符串的长度： 字符串对象.length()\n字符串的长度是方法    数组的长度是属性\n```\n\n### 截取字符串\n\n```java\nString substring(int beginIndex,int endIndex)  注意：包头不包尾，包左不包右\nString substring(int beginIndex)  截取到末尾 \n```\n\n### 替换字符串\n\n```java\nString replace(旧值,新值)  //注意：只有返回值才是替换之后的结果\n```\n\n### 字符串原理\n\n```java\n字符串存储的内存原理\n\t直接赋值会复用字符常量池中的\n\tnew出来的不会复用，而是开辟一个新的空间\n==号比较的到底是什么？\n\t基本数据类型比较数据值\n\t引用数据类型比较地址值   .equals()方法\n字符串拼接的底层原理\n\t如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。\n\t如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存。\n```\n\n### 字符串拼接的底层原理\n\n![](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-01_21-59-54.png)\n\n## StringBuilder概述\n\n```java\nStringBuilder可以看成一个容器，创建之后里边的内容是可变的！！！\n\t作用：提高字符串的操作效率\n\t比如单纯的字符串拼接操作会产生新的字符串造成空间的浪费\n\t提高效率的底层原理\n\t\t所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存\n构造方法\n\tpublic StringBuilder()    创建一个空白可变字符串对象，不含有任何内容\n\tpublic StringBuilder(String str) 根据字符串的内容，来创建可变字符串对象\n```\n\n### StringBuilder常用方法\n\n```java\npublic StringBuilder append(任意类型) 添加数据，并返回对象本身\npublic StringBuilder reverse() 反转容器中的内容\npublic int lengh() 返回长度（字符出现的个数）\npublic String toString() 通过toString()就可以实现把StringBuilder转换为String\n```\n\n### StringBuilder源码分析\n\n```java\n默认创建一个长度为16的字节数组\n添加的内容长度小于16，直接存\n添加的内容大于16会扩容（原来的容量*2+2）\n如果扩容之后还不够，以实际长度为准\n```\n\n\n\n## **StringJoiner概述**\n\n```java\nStringJoiner和StringBuilder一样，也可以看成一个容器，创建之后里边的内容是可变的\n\t作用：\n\t\t提高字符串的操作效率，而且代码编写特别简介，但是目前市场上很少有人用。\n\t构造方法\n\tpublic StringJoiner(间隔符号)  创建一个StringJoiner对象，指定拼接时的间隔符号\n\tpublic StringJoiner(间隔符号,开始符号,结束符号) 创建一个StringJoiner对象，指定拼接时的间隔符号开始符号和结束符号\n\n```\n\n### **StringJoiner常用方法**\n\n```java\npublic StringJoiner add(添加的内容)  添加数据，并返回对象本身\npublic int length()  返回长度\npublic String toString()  返回一个字符串该字符串就是拼接后的结果 \n```\n\n## 集合\n\n### Collection单列集合（接口，需要创建实现类对象）\n\n![Snipaste_2023-03-16_14-59-52](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-16_14-59-52.png)\n\n```java\nCollection\n\tCollection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。\npublic boolean add(E e)\t\t把给定的对象添加到当前集合中\npublic void clear()\t\t清空集合中所有的元素\npublic boolean remove(E e)\t把给定的对象在当前集合删除\npublic boolean contains(Object obj)\t判断当前集合是否包含给定对象\npublic boolean isEmpty()\t判断当前集合是否为空\npublic int size() \t\t返回集合元素个数\n    \n需要注意：\n     contains底层是依赖equals方法进行判断是否存在的\n        // 所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法\n    \n---------------------------------------------------Collection集合获取迭代器\n \n\tIterator<E> iterator()\t\t返回迭代器对象，默认指向当前集合的0索引\n\n```\n\n\n\n\n\n![](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-18_15-02-50.png)\n\n#### List集合（也是接口，需要创建实现类的对象）\n\n```java\nList集合的特点\n\t有序：\n\t\t存和取的元素顺序一致\n\t有索引：\n\t\t可以通过索引操作元素\n\t可重复：\n\t\t存储的元素可以重复\n\nList集合的特有方法\n\tCollection的方法List都继承了\n\tList集合因为有索引，所以多了很多索引操作的方法\n\n方法名称\nvoid add(int index,E element) //在集合中按指定位置插入元素\nE remove(int index)\t//删除指定索引的元素，返回被删除的元素\nE set(int index,E element)\t//修改指定索引的元素，返回被修改的元素\nE get(int index)\t//返回指定索引处的元素\n```\n\n\n\n##### ArrayList集合\n\n##### 集合和数组的对比\n\n```java\n集合\n\t长度可变\n\t可以存引用数据类型（存基本数据类型的话需要包装类）\n    E   泛型：限定集合中存储数据的类型\t\n数组\n\t长度固定\n\t可以存基本数据类型和引用数据类型\n```\n\n##### ArrayList成员方法(增删改查)\n\n```java\nboolean add(E e)  //添加元素，返回值表示是否添加成功\nboolean remove(E e)//删除指定元素，返回值表示是否删除成功\nE remove(int index) //删除指定索引的元素，返回被删除的元素\nE set(int index,E e) //修改指定索引下的元素，返回原来的元素\nE get(int index) //获取指定索引的元素\nint size()  //集合的长度，也就是集合中元素的个数\n```\n\n#### \n\n#### Set系列集合（Set接口中的方法和Collection的Api一致）\n\n```\nSet集合特点：\n\t无序：存取顺序不一致\n\t不重复：可以去除重复\n\t无索引:没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素\n\t\nSet集合的实现类：\n\tHashSet：无序、不重复、无索引\n\tLinkedHashSet：有序、不重复、无索引\n\tTreeSet：可排序、不重复、无索引\n```\n\n#### HashSet\n\n~~~\nHashSet底层原理：\n\tHashSet集合底层采取哈希表存储数据\n\t哈希表是一种对于增删改查数据性能都较好的结构\n\t1.创建一个默认长度16，默认加载因子为0.75的数组，数组名为table\n\t2.根据元素的哈希值跟数组的长度计算出应存入的位置\n\t3.判断当前位置是否为null，如果是null直接存入\n\t4.如果位置不为null，表示有元素，则调用equals方法比较属性值\n\t5.一样： 不存\t\t不一样： 存入数组，形成链表\n\t\tJDK8以前： 新元素存入数组，老元素挂在新元素下面\n\t\tJDK8以后： 新元素直接挂在老元素下面\n\tJDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树\n\t\n\t如果集合中存储的时自定义对象，必须重写hashCode和equals方法\n\n\nHashSet的三个问题\n\tHashSet为什么存和取的顺序不一样？\n\t\t遍历时从数组的0索引开始，遇到链表先遍历完再进行数组的遍历\n\t\n\tHashSet为什么没有索引？\n\t\t因为HashSet在底层是，数组链表和红黑树组成的的结构，不知道以谁当索引\n\t\n\tHashSet是利用什么机制保证数据去重的？\n\t\tHashSet方法和equals方法\n\n哈希表组成：\n\tJDK8之前：\n\t\t数组+链表\n\tJDK8开始：\n\t\t数组+链表+红黑树\n\n\n哈希值：\n\t对象的整数表现形式\n\t根据hashCode方法算出来的int类型的整数\n\t该方法定义再Object类中，所有对象都可以调用，默认使用地址值进行计算\n\t一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值\n\t\n对象的哈希值特点：\n\t如果没有重写hashCode方法，不同对象计算出的哈希值是不同的\n\t如果已经重写hashCode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的\n\t在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希碰撞）\n~~~\n\n##### LinkedHashSet\n\n~~~\n继承HashSet直接用HashSet的方法即可\n底层是使用双向链表保证数据的顺序\n特点：\n\t有顺序、不重复、无索引\n~~~\n\n#### TreeSet\n\n~~~java\n特点：\n\t可排序、不重复、无索引\n\t\nTreeSet添加的两种规则：\n\t方式一：\n\t\t默认排序，自然排序：\n\t\t\tJavabean类实现Comparable接口指定比较规则\n\t\t\t\n\t// 返回值：\n    //     负数：认为要添加的元素是小的，存在左边\n    //     正数：认为要添加的元素是大的，存在右边\n    //     0：认为要添加的元素已经存在，舍弃\n    @Override\n    public int compareTo(Student o) {\n        //指定排序的规则\n\t\t//按照年龄比较\n        \n        return this.getAge()-o.getAge();\n        // return 0;\n    }\n\n\n\t方式二：\n        比较器排序：创建TreeSet对象的时候，传递比较器Comparator指定规则\n~~~\n\n### 单列集合总结\n\n~~~\n1.如果想要集合中的元素可重复\n\t用ArrayList集合，基于数组的\n2.如果想要集合中元素重复，而且当前的增删操作明显多于查询\n\t用LinkedList集合，基于链表的\n3.如果想对集合中的元素去重\n\t用HashSet集合，基于哈希表的\n4.如果想对集合中的元素去重，而且保证存取顺序\n\t用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet\n5.如果想对集合中的元素进行排列\n\t用TreeSet集合，基于红黑树，后续也可以用List集合实现排序\n~~~\n\n\n\n### Map双列集合（Map是双列集合的顶层接口，它的共功能是全部双列集合都可以继承使用的）\n\n~~~\n双列集合的特点\n\t双列集合一次需要存一对数据，分别为键和值\n\t键不能重复，值可以重复\n\t键和值是一一对应的，每一个键只能找到自己对应的值\n\t键+值这个整体 我们称之为\"键值对\" 或者 \"键值对对象\"，在java中叫做\"Entry对象\"\n\t\nTreeMap特点：\n\t不重复、无索引、可排序\n\t底层基于红黑树实现排序，增删改查性能好\nTreeMap集合排序的两种方式：\n\t实现Compareble接口，指定比较规则\n\t创建集合时传递Com【arator比较器对象，指定比较规则\n~~~\n\n![Snipaste_2023-03-20_15-15-33](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-20_15-15-33.png)\n\n#### Map常见的API\n\n~~~\nV put (K key,V value)\t\t添加元素\nV remove(Object key)\t\t根据键删除键值对元素\nvoid clear()\t\t\t\t移除所有的键值对元素\nboolean containsKey(Object key)\t判断集合是否包含指定的键\nBoolean containsValue(Object value) 判断集合是否包含指定的值\nboolean isEmpty() \t\t\t判断集合是否为空\nint size()\t\t\t\t\t集合的长度，也就是集合中键值对的个数\nint get(Object key)\t\t\t判断键出现的次数\n~~~\n\n##### Map遍历\n\n~~~java\n遍历方式有三种\n\t1.键找值\n\t//获取所有的键，把这些键放到一个集合中\n        Set<String> keySet = m.keySet();\n        然后通过Set集合遍历\n    //利用map中对应的key键获取对应的值value\n        String value = m.get(key);\n        System.out.println(\"key = \"+key+\"  value = \"+value);\n\t2.不推荐\n    3.利用Lambda改写BiConsumer\n        m.forEach((key,value)-> System.out.println(key+\"=\"+value));\n\n\n统计思想，利用map集合进行排序\n    如果题目中没有要求对结果进行排序，默认使用HashMap\n\t如果题目中要求对结果进行排序，默认使用TreeMap\n    \n~~~\n\n\n\n\n\n## 遍历\n\n### Colleation遍历\n\n#### 迭代器遍历\n\n```\n迭代器不依赖索引\nIterator中常用方法\n\nboolean hasNext() 判断当前位置是否有元素，有元素返回true，没有元素返回false\n\nE next() \t获取当前位置的元素，并将迭代器对象移向下一个位置\n```\n\n#### 增强for\n\n```java\n增强for的底层就是迭代器，为了简化迭代器的代码书写的\n他是JDK5以后出现的，其内部原理就是一个Iterator迭代器\n所有的单列集合和数组才能用增强for进行遍历\n\n格式：\n\tfor(元素的数据类型 变量名:数组或集合){\n        \n    }\n例如：\n    for(String s : List){\n        System.out.println(s);\n    }\n\n增强for的细节：\n    \t修改增强for中的变量，不会改变集合中原本的数据\n```\n\n#### Lambda表达式遍历\n\n```\nJDK8开始的新技术Lambda表达式，提供了一种更简单，更直接的遍历集合的方式\n() -> \ndefault void forEach(Consumer<? super T> action) :\t\t结合Lambda遍历集合\n```\n\n\n\n\n\n### 基本数据类型对应包装类\n\n![Snipaste_2023-03-02_21-18-07](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-02_21-18-07.png)\n\n## 其他\n\n### 反射\n\n~~~\n什么是反射？\n\t反射允许对封装类的字段（成员变量）\n\t方法（成员方法）\n\t构造函数（构造方法）\n\t的信息进行编程访问\n~~~\n\n\n\n### 多线程\n\n~~~\n什么是多线程？\n\t有了多线程，我们就可以让程序同时做多件事情\n多线程的作用？\n\t提高效率\n多线程的应用场景？\n\t只要你想让多个事情同时运行就需要用到多线程\n~~~\n\n\n\n#### 并发与并行\n\n~~~\n并发：\n\t在同一时刻，有多个指令在单个CPU上   交替   执行\n\t\n并行：\n\t在同一时刻，有多个指令在多个CPU上   同时   执行\n~~~\n\n#### 多线程三种实现方法对比\n\n~~~\n第一种：\n\t继承Thread类\n\t\t优点：\n\t\t\t编程比较简单可以直接使用Thread类中的方法\n\t\t缺点：\n\t\t\t扩展性较差，不能再继承其他类\n第二种：\n\t实现Runnable接口\n\t\t优点：\n\t\t\t扩展性强，实现该接口的同时还可以继承其他的类\n\t\t缺点：\n\t\t\t编程相对复杂，不能直接使用Thread类中的方法\n第三种：\n\t实现Callable接口    （同第二种）\n\t不过可以获取线程运行的结果\n~~~\n\n#### 线程常用的成员方法\n\n~~~java\n// 返回此线程的名称\nString getName()\n\n// 设置线程的名字（构造方法也可以设置名字）\nvoid setName(String name)\n    \n// 获取当前线程的对象\nstatic Thread currentThread()\n    \n// 让线程休眠指定的时间，单位为毫秒\nstatic void sleep(Long time)\n    \n// 设置线程的优先级\nsetPriority(int newPriority)\n    \n// 获取线程的优先级\nfinal int getPriority()\n    \n// 设置为守护线程\nfinal void setDaemon(boolean on)\n    \n// 出让线程/礼让线程\npublic static void yield()\n    \n// 插入线程/插队线程\npublid static void join()\n~~~\n\n#### 线程的生命周期\n\n![Snipaste_2023-03-29_11-50-03](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-29_11-50-03.png)\n\n#### 同步代码块\n\n~~~\n把操作共享数据的代码锁起来\n格式：\n\tsynchronized(锁){\n\t\t操作共享数据的代码\n\t}\n特点：\n\t锁默认打开，有一个线程进入，锁自动关闭\n\t里面所有的代码全部执行完毕，线程出来，锁自动打开\n~~~\n\n#### Lock锁\n\n~~~java\nLock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作\nLock中提供了获得锁和释放锁的方法\nvoid locl():获得锁\nvoid unlock():释放锁\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\nReentrantLock的构造方法\nReentrantLock():创建一个ReentrantLock的实例化\n~~~\n\n### 线程池\n\n~~~\nExecuors：\n\t线程池的工具类通过调用方法返回不同类型的线程池对象\n\n线程池代码实现：\n\n// 创建一个没有上线的线程池\npublic static ExecutorService newCachedThreadPool()\n\n// 创建有上限的线程池\npublic static ExecutorService newFixedThreadPool(int nThreads)\n\n\n线程池主要核心原理\n\t1.创建一个池子，池子中是空的\n\t2.提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可\n\t3.但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待\n\n\n自定义线程池\n\t小结：\n\t\t1.创建一个空的池子\n\t\t2.有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程\n\t\t\n不断的提交任务，会有三个临界点：\n\t1.当核心线程满时，在提交任务就会排队\n\t2.当核心线程满，队伍满时，会创建临时线程\n\t3.当核心线程满，队伍满，临时线程满时，会触发任务拒绝策略\n~~~\n\n### 网络编程\n\n~~~\n什么是网络编程？\n\t在网络通信协议下，不同计算机上运行的程序，进行的数据传输\n\t\n表示互联网协议（IP）地址的类\n\tInetAddress\n\t\n端口号：\n\t应用程序在设备中的唯一标识\n\t\n\t端口号：\n\t\t由两个字节表示的整数，取值范围：0~65535\n\t\t其中0~1023之间的端口号用于一些知名的网络服务或者应用\n\t\t我们自己使用1024以上的端口号就可以了\n\t注意：\n\t\t一个端口号只能被一个应用程序使用\n\t\t\n\t\t\n协议：\n\t计算机网络中，连接和通信的规则被称为网络通信协议\n\t\n\tUDP协议：\n\t\t用户数据报协议\n\t\tUDP是  面向无连接  通信协议\n\t\t速度快，有大小限制一次最多发送64K，数据不安全，易丢失\n\t\t\n\tUDP的三种通信方式\n\t\t1.单播：\n\t\t\t以前的代码就是单播\n\t\t2.组播：\n\t\t\t组播地址：224.0.0.0 ~ 239.255.255.255\n\t\t\t\t\t其中224.0.0.0 ~ 224.0.0.255为预留的组播地址\n\t\t3.广播：\n\t\t\t广播地址：255.255.255.255\n\tTCP协议：\n\t\t传输控制协议TCP\n\t\tTCP协议是  面向连接  的通信协议\n\t\t速度慢，没有大小限制，数据安全\n\t\t\n客户端：\n\t1.创建客户端的Socket对象与指定服务端连接\n\tSocket(String host,int port)\n\t2.获取输出流，写数据\n\tOutputStream  getOutputStream()\n\t3.释放资源\n\tvoid close()\n\t\n服务器：\n\t1.创建服务器端的Socket对象\n\tServerSocket(int port)\n\t2.监听客户端连接，返回一个Socket对象\n\tSocket accept()\n\t3.获取输入流，读数据，并把数据显示在控制台\n\tInputStream   getInputStream()\n\t4.释放资源\n\tvoid close()\n~~~\n\n#### TCP通信程序（三次握手）\n\n![Snipaste_2023-03-30_09-20-17](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-30_09-20-17.png)\n\n#### TCP通信程序（四次挥手）\n\n![Snipaste_2023-03-30_09-23-49](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-30_09-23-49.png)\n\n### IO流\n\n~~~\n什么是IO流\n\t存储和读取数据的解决方啊\n\tI:intput\tO:output\n\t流：像水流一样传输数据\n\nIO流的作用：\n\t用于读写数据（本地文件，网络）\n\t\nIO流按照流向可以分类哪两种流\n\t输出流： 程序  ->  文件\n\t输入流： 文件  ->  程序\n\t\nIO流按照操作文件的类型可以分类哪两种流\n\t字节流：可以操作所有类型的文件\n\t字符流：只能操作纯文本文件\n\t\n什么是纯文本文件\n\t用Windows系统自带的记事本打开并且能够读懂的文件\n~~~\n\n\n\n### File\n\n~~~java\nFile表示什么：\n    File对象表示路径，可以是文件，也可以是文件夹。\n    这个路径可以是存在的，也可以是不存在的\n    \n绝对路径和相对路径是什么意思：\n    绝对路径是带盘符的\n    相对路径是不带盘符的，默认到当前项目下去找\n\nFile三种构造方法：    \n\t// 根据文件路径创建文件对象\n\tpublic File(String pathname)\n    \n\t// 根据父路径名字符串和子路径名字符串创建文件对象\n\tpublic File(String parent, String chile)\n    \n\t// 根据父路径对应文件对象和子路径名字符串创建文件对象\n\tpublic File(File parent,String chile)\n    \n~~~\n\n\n\n#### File常见的成员方法\n\n~~~\n// 判断此路径名表示的File是否为文件夹\nboolean isDirectory()\n\n// 判断此路径名表示的File是否为文件\nboolean isFile()\n\n// 判断此路径名表示的File是否为存在\nboolean exists()\n\n// 返回文件的大小(字节数量)\nlong length()\n\n// 返回文件的绝对路径\nString getAbsolutePath()\n\n// 返回定义文件时使用的路径\nString getPath()\n\n// 返回文件的名称，带后缀\nString getName()\n\n// 返回文件的最后修改时间(时间毫秒值)\nLong lastModified()\n\n=================(创建、删除)==============\n// 创建一个新的空的文件\nboolean createNewFile()\n\n// 创建单级文件夹\nboolean mkdir()\n\n// 创建多级文件夹\nboolean mkdirs()\n\n// 删除文件、空文件见！！！注意删除的时候不走回收站\nboolean delete()\n\n=================获取并遍历===============\n// 获取当前该路径下所有内容\nFile[] listFiles()\n~~~\n\n#### FileOutPutStream书写细节（字节流）\n\n~~~\n字节输出流的细节：\n  \t1.创建字节输出流对象\n        细节1：参数是字符串表示的路径或者是File对象都是可以的\n        细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的\n        细节3: 如果文件中存在数据，则会清空数据\n        \n     2.写出数据：\n        细节1：write输入的是整数，但是保存在本地的是ASCII的对应字符\n        \n     3.释放资源：\n        每次使用完流之后都要释放资源\n        \n        \nFileOutPutStream写数据的3中方式\n\n//一次写一个数据\nvoid write(int b)\n\n//一次写一个字节数组数据\nvoid write(byte[] b)\n\n//一次写一个字节数组的部分数据\nvoid write(byte[] b,int off,int len)\n~~~\n\n#### FileInPutStream书写细节（字节流）\n\n~~~\n1.创建字节输入流对象：\n\t细节1：如果文件不存在，就直接报错\n\t\n2.读取数据：\n\t细节1：一次读一个字节，读出来的数据是ASCII上对应的数字\n\t细节2：读到文件末尾了，read方法返回-1\n\n3.释放资源：\n\t细节：每次使用完流必须要释放资源\n~~~\n\n### FileReader（字符流）\n\n~~~java\n//第一步：创建对象\npublic FileReader(File file)        创建字符输入流关联本地文件\n public FileReader(String pathname)  创建字符输入流关联本地文件\n\n//第二步：读取数据\npublic int read()                   读取数据，读到末尾返回-1\npublic int read(char[] buffer)      读取多个数据，读到末尾返回-1\n\n//第三步：释放资源\npublic void close()                 释放资源/关流\n~~~\n\n#### 字符流原理解析\n\n~~~\n1.创建字符输入流对象\n\t底层：关联文件，并创建缓冲区（长度为8192的字节数组）\n\n2.读取数据\n\t底层：\n\t\t1.判断缓冲区中是否有数据可以读取\n\t\t2.缓冲区没有数据：\n\t\t\t\t就从文件中获取，撞到缓冲区中，每次尽可能装满缓冲区 如果文件中也没有数据了，返回-1\n\t\t3.缓冲区有数据：\n\t\t\t\t就从缓冲区读取\n\t\t\t空参的read方法：\n\t\t\t\t一次读取一个字节，遇到中文一次读多个字节，把字节解码并转换成十进制返回\n\t\t\t有参的read方法：\n\t\t\t\t把读取字节，解码，强转三步合并了，强转之后的字符放到数组中\n~~~\n\n\n\n### 缓冲流\n\n~~~\n1.缓冲流有几种\n\t字节缓冲输入流：BufferedInputStream()\n\t字节缓冲输出流：BufferedOutputStream()\n\t字符缓冲输入流：BufferedReader()\n\t字节缓冲输出流：BufferedWriter()\n\n2.缓冲流为什么能提高性能\n\t缓冲流自带长度为8192的缓冲区\n\t可以显著提高字节流的读写性能\n\t对于字符流提升不明显，有两种特有的方法\n\n3.字符缓冲流有两个特有的方法\n\t字符缓冲输入流 BufferedReader: readLine()\n\t字符缓冲输出流 BufferedWriter: newLine()\n~~~\n\n### 转换流\n\n~~~\n转换流的名字：\n\t字符转换输入流：InputStreamReader\n\t字符转换输出流：OutputStreamWriter\n转换流的作用是什么：\n\t指定字符集读写数据\n\t字节流想要使用字符流中的方法\n~~~\n\n### 序列化流/对象操作输出流\n\n~~~\n可以把Java中的对象写到本地文件中\n\n构造方法\n// 把基本流包装成高级流\npublic ObjectOutputStream(OutputStream out)\n\n成员方法\n// 把对象序列化(写出)到文件中去\npublic final void wtiterObject(Object obj)\n\n\n序列化小细节：\n\t使用对象输出流将对象保存到文件时会出现问题\n\n解决方案：\n\t需要让JavaBean类实现Serializable接口\n\t\n如果一个对象的某个成员变量的值不想被序列化\n\t给该成员变量加上transient关键字修饰\n\t该关键字标记的成员变量不参与序列化过程\n~~~\n\n### 打印流\n\n~~~\n分类：\n\t一般是指PintStream，PrintWrite\n特点1：\n\t打印流只操作文件目的地，不操作数据源\n特点2：\n\t特有的写出方法可以实现，数据原样写出\n特点3：\n\t特有的写出方法，可以实现自动刷新，换行\n\t\n字节打印流：\n\t构造方法\n\t//关联字节输出流/文件/文件路径\n\tpublic PrintStream(OutStream/File/String)\n\t//指定字符编码\n\tpublic PrintStream(String fileName, Charset charset)\n\t\n\t成员方法：\n\t//规则和之前一样，将指定的字节写出\n\tvoid write(int b)\n\t\n\t特有方法：\n\t//打印任意数据，自动换行，自动刷新\n\tprintln()\n\t//打印任意数据，不换行\n\tprint()\n\t//带有占位符的打印语句，不换行\n\tprintf(String format, Object... args)\n~~~\n\n\n\n\n\n### 字符集\n\n~~~\n1.在计算机中，任意数据都是以二进制的形式来存储的\n2.计算机中最小的存储单元是一个字节\n3.ASCII字符集中，一个英文占一个字节\n4.简体中文版Windows，默认使用GBK字符集\n5.GBK字符集完全兼容ASCII字符集\n\t一个英文占一个字节，二进制第一位是0\n\t一个中文占两个字节，二进制高位字节的第一位是1\n\t\nUnicode字符集的UTF-8下\n\t一个英文占一个字节，二进制第一位是0\n\t一个中文占3个字节，1110XXXX 10XXXXXX 10XXXXXX（首位是1）\n~~~\n\n\n\n### 异常\n\n~~~\n异常：\n\t就是代表程序出的错误\n\n误区：\n\t不是让我们以后不出异常，而是程序出了异常之后，该如何处理\n\t\n异常体系的最上层父类是谁？异常分为几类？\n\t父类：Exception\n\t异常分为两类：编译时异常、运行时异常\n\n编译时异常和运行时异常的区别\n\t编译时异常：\n\t\t没有继承RuntimeException的异常，直接继承于Exception\n\t\t编译阶段就会错误提示\n\t运行时异常：\n\t\tRuntimeException本身和子类\n\t\t编译阶段没有错误提示，运行时出现的\n\t\n~~~\n\n![Snipaste_2023-03-22_17-41-33](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-22_17-41-33.png)\n\n#### 捕获异常\n\n~~~java\n格式：\n    try{\n        可能出现异常的代码;\n    } catch(异常类名 变量名) {\n        异常的处理代码;\n    }\n目的：\n    当代码出现异常时，可以让程序继续往下执行\n~~~\n\n![Snipaste_2023-03-22_18-23-55](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-22_18-23-55.png)\n\n### 方法引用\n\n~~~\n1.什么是方法引用？\n\t把已经存在的方法拿过来用，当作函数式接口中抽象方法的方法体\n2.::是什么符号？\n\t方法引用符\n3.方法引用时需要注意什么？\n\t需要有函数式接口\n\t被引用方法必须已经存在\n\t被引用方法的形参和返回值需要跟抽象方法保持一致\n\t被引用方法的功能要满足当前的需求\n\t\n\t\n=================================================================\n1.引用静态方法\n\t类名::静态方法\n2.引用成员方法\n\t对象::成员方法\n\tthis::成员方法\n\tsuper::成员方法\n3.引用构造方法\n\t类名::new\n4.使用类名引用成员方法\n\t类名::成员方法\n5.引用数组的构造方法\n\t数据类型[]::new\n~~~\n\n\n\n### Stream流\n\n~~~\nStream流的思想\n\nStream流的作用：\n\t结合了Lambda表达式，简化集合，数组的操作\n\t\nStream流的使用步骤：\n\t1.先得到一条Stream流（流水线），并把数据放上去\n\t2.利用Stream流中的API进行各种操作\n\t过滤\t\t转换\t\t中间方法   方法调用完毕之后，还可以调用其他方法\n\t统计\t\t打印\t\t终结方法   最后一步，调用完毕之后，不能调用其他方法\n\t\n使用流程：\n获取方式\t\t方法名\t\t\t  \t\t\t\t\t说明\n单列集合\tdefault Stream<E> stream()\t\tCollection中的默认方法\n双列集合\t\t无\t\t\t\t\t\t\t无法直接使用Stream流\n数组\t\tpublic static<T>Stream<T>stream(T[] Array)\tArray工具类\n一堆零散的数据\t\t\tStream<T>of(T...values)\tStream接口的静态方法\n~~~\n\n### Stream流的中间方法\n\n~~~\n过滤\n\tStream<T>filter(Predicate<? super T>predicate) \n\t\n获取前几个元素\n\tStream<T>limit(long maxSize)\n\t\n跳过前几个元素\n\tStream<T>skip(long n)\n\t\n元素去重，依赖（hashCode和equals方法）\n\tStream<T>distinct()\n\t\n合并a和b两个流为一个流\n\tstatic<T>Stream<T>concat(Stream a,Stream b)\n\t\n转换流中的数据类型\n\tStream<R>map(Function<T,R> mapper)\n\t\n注意点：\n\t1.中间方法，返回新的Stream流，原来的Stream流只能用一次，建议使用链式编程\n\t2.修改Stream流中的数据，不会影响原来集合或者数组中的数据\n~~~\n\n### Stream流的终结方法\n\n~~~java\n遍历\nvoid forEach(Consumer action)\n\n统计\nlong count()\n\n收集流中的数据，放到数组中\ntoArray()\n\n收集流中的数据，放到集合中\ncollect(Collector collector)\n~~~\n\n\n\n### 不可变集合\n\n~~~\n在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合\n\n方法：\nstatic <E> List<E> of(E...elements) 创建一个具有指定元素的List集合对象\nstatic <E> Set<E> of(E...elements) 创建一个具有指定元素的Set集合对象\nstatic <E,V> Map<K,V> of(E...elements) 创建一个具有指定元素的Map集合对象\n\n注意：\n\t这个集合不能添加，不能删除，不能修改\n\t\n\t\n不可变集合的特点：\n\t定义完成后不可以修改，或者添加，删除\n如何创建不可变集合：\n\tList，Set，Map接口中，都存在of方法可以创建不可变集合\n三种方式的细节：\n\tList：\n\t\t直接用\n\tSet：\n\t\t元素不能重复\n\tMap：\n\t\t元素不重复，键值对数量最多是10个\n\t\t超过10个用ofEntries方法\n\t\t（如果JDK超过10  可以用copyOf方法）\n\t\tMap<String, String> map = Map.copyOf(hashMap);\n~~~\n\n\n\n\n\n### Collections工具类\n\n~~~ \n作用：\n\tCollections不是集合，而是集合的工具类\n\t\nCollections常用的API\n\n方法名称\npublic static <T> boolean addAll(Collection<T> c,T...elements)\n\t批量添加元素\npublic static void shuffke(List<?> list) \n\t打乱list集合元素的顺序。\npublic static <T> void sort(List<T> List)\n\t排序\npublic static <T> void sort(List<T> List,Comparator<T> c)\n\t根据指定的规则进行排序\npublic static <T> int binarySearch(List<T>, T key)\n\t以二分查找法查找元素\npublic static <T> void copy(List<T> dest,List<T> src)\n\t拷贝集合中的元素\npublic static <T> int fill(List<T> list,T obj)\n\t使用指定的元素填充集合\npublic static <T> void max/min(Collection<T> coll)\n\t根据默认的自然排序获取最大/最小值\npublic static <T> void swap(List<?> list,int i,int j)\n\t交换集合中指定位置的元素\n~~~\n\n\n\n### 可变参数\n\n~~~\nJDK5\n可变参数\n方法形参的个数时可以发生变化的0 1 2 3......\n\n作用：\n\t在形参中接收多个数据\n\n格式：\n\t数据类型...名字\n\n\n底层：\n\t可变参数底层就是一个数组\n\t只不过不需要我们自己创建了，java会帮我们创建好\n\t\npublic static int getSum(int...args){\n\n}\n\n\n小细节：\n\t在方法的形参中可变参数最多可以写一个\n\t如果在方法中除了可变参数还有其他形参，那么可变参数要写在最后\n~~~\n\n\n\n### 泛型\n\n```\n泛型：\n\t是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查\n\t\n泛型的格式：\n\t<数据类型>\n注意：\n\t泛型只能支持引用数据类型\n\t如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合添加任意的数据类型，带来一个坏处，我们在获取数据的时候，无法使用他的特有行为\n\t\n\t\n扩展知识：\n\tJava中的泛型是伪泛型\n\t在Java文件中泛型存在，编译后泛型就不存在了\n\t叫做泛型的擦除\n\n泛型的细节：\n\t泛型中不能写基本数据类型\n\t指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型\n\t如果不写泛型，类型默认是Object\n\t\n泛型方法：\n\t方法中形参类型不确定时\n\t\t方案1：\n\t\t\t使用类名后面定义的泛型\t\t本类中所有的方法都能用\n\t\t方案2：\n\t\t\t在方法申明上定义自己的泛型\t只有本方法可以用\n\t\t\t\n泛型方法格式：\n\t修饰符<类型>返回值类型 方法名(类型 变量名){\n\t\n\t}\n\t\n\t//K T V E\n\tpublic <T> void show(T,t){\n\t\n\t}\n\t\n泛型接口：\n\t格式：\n\t\t修饰符 interface 接口名<类型>{\n\t\t\n\t\t}\n\t举例：\n\t\tpublic interface List<E>{\n\t\t\n\t\t}\n\t\t\n重点：\n\t如何使用一个带泛型的接口\n\t\n方式1：\n\t实现类给出具体类型\n方式2：\n\t实现类延续泛型，创建对象时再确定\n```\n\n\n\n### Lanmbda表达式\n\n```java\nLambda的省略规则\n    1.参数类型可以省略不写\n\t2.如果只有一个参数，参数类型可以省略，同时()也可以省略\n\t3.如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略\n    \nlambda表达式的标准格式\n\t() -> {\n    \n\t}\nLambda表达式的基本作用：\n\tLambda表达式可以用来简化匿名内部类的书写\n\tLambda表达式只能简化函数式接口的匿名内部类的书写\n\nLambda表达式有什么使用前提：\n    必须式接口的匿名内部类，接口中只能有一个抽象方法\n    \nLambda的好处：\n    Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，它可以写出更简洁，更灵活的代码，作为一种更紧凑的代码风格，使Java语言表达能力得到了提升\n```\n\n\n\n### 计算机存储规则\n\n![Snipaste_2023-03-04_14-40-29](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-04_14-40-29.png)\n\n### 重新认识main方法\n\n```\npublic:\n\t被jvm调用，访问权限足够大\nstatic：\n\t被jvm调用，不用创建对象，直接类名访问\n\t因为main方法是静态的，所以测试类中其他方法也需要是静态的\nvoid：\n\t被jvm调用，不需要给返回值\nmain：\n\t一个通用的名称，虽然不是关键字，但是被jvm识别\nString[] args：\n\t以前用于接收键盘录入数据的，现在没用\n```\n\n### 重写\n\n```\n方法的重写\n\t当父类的方法不能满足子类现在的需求时，需要进行方法的重写\n书写格式\n\t在继承体系中，子类出现了和父类一样的方法声明，我们就称为子类这个方法是重写的方法\n\n@Override重写注解\n\t1.@Override是重写后的方法上，校验子类重写时语法是否正确\n\t2.加上注解后如果有红色波浪线，表示语法错误\n\t3.建议重写方法都加@Override注解，代码安全，优雅。\n```\n\n\n\n### 注解\n\n```\n@Override重写注解\n\t1.@Override是重写后的方法上，校验子类重写时语法是否正确\n\t2.加上注解后如果有红色波浪线，表示语法错误\n\t3.建议重写方法都加@Override注解，代码安全，优雅。\n\n@FunctionalInterface函数式接口（Lambda表达式的时候使用）\n\t有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加\t@FunctionalInterface注解判断\n```\n\n### 包\n\n```\n使用其他类的规则\n\t使用同一个包中的类时，不需要导包\n\t使用java.lang包中的类时，不需要导包\n\t其他情况都需要导包\n\t如果同时使用两个包中的同名类，需要使用全类名\n```\n\n### 代码块\n\n```java\n代码块的分类\n\t局部代码块，构造代码块，静态代码块\n\t\n局部代码块\n\t提前结束变量的生命周期（已经淘汰）\n构造代码块\n\t抽取构造方法中的重复代码（不够灵活）\n\t\t\t{\n    \n\t\t}\n静态代码块\n\t数据的初始化 \n\t\tstatic{\n\t\t\n\t\t}\n```\n\n### 抽象类（abstract）\n\n```\n抽象类的作用是什么\n\t抽取共性时，无法确定方法体，就把方法定义为抽象的。\n\t强制让子类按照某种格式重写\n\t抽象方法所在的类，必须时抽象类\n\n抽象类和抽象方法的格式\n\tpublic abstract 返回值类型 方法名(参数列表);\n\tpublic abstract class 类名{}\n\n继承抽象类有哪些要注意\n\t要么重写抽象类中所有的方法\n\t要么时抽象类\n```\n\n### 设计模式\n\n```\n设计模式是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性，程序的重用性\n```\n\n#### 适配器设计模式\n\n```\n解决接口与接口实现类之间的矛盾问题\n\t\n当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式\n\t\n书写步骤 \n\t编写中间类XXXAdapter，实现对应的接口\n\t对接口中的抽象方法进行空实现\n\t让真正的实现类继承中间类，并重写需要用的方法\n\t为了避免其他类创建适配器类的对象，中间的适配器类\n\t用abstract进行修饰\n```\n\n### 内部类\n\n```\n类的五大成员：\n\t属性，方法，构造方法，代码块，内部类\n\t\n\n内部类\n\t表示的事物是外部类的一部分\n\t内部类单独出现没有意义\n\t\n内部类的访问特点\n\t内部类可以直接访问外部类的成员，包括私有\n\t外部类要访问内部类的成员，必须创建对象\n\t\n成员内部类\n\t写在成员位置，属于外部类的成员\n\t\n\t获取成员内部类对象的两种方式\n\t\t方式一：\n\t\t\t当成员内部类被private修饰时\n\t\t\t在外部类中编写方法，对外提供内部类的对象\n\t\t方式二：\n\t\t\t当成员内部类被非私有修饰时，直接创建对象\n\t\t\tOuter.Inner oi = new Outter().new Inner();直接创建对象\n\t外部类成员变量和内部类成员变量重名时，在内部类中如何访问\n\t\tSystem.out.pringln(Outer.this.变量名);\n\t\t\n静态内部类\n\n局部内部类\n\n匿名内部类\n\t什么是匿名内部类：\n\t\t隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置\n\t匿名内部类的格式：\n\t\tnew 类名或者接口名(){\n\t\t\t重写方法;\n\t\t}\n\t格式的细节\n\t\t包含了继承或实现，方法重写，创建对象。\n\t\t整体就是一个类的子类对象或者接口的实现类对象\n\t使用场景\n\t\t当方法的参数是接口或者类时\n\t\t以接口为例，可以传递这个接口的实现类对象，\n\t\t如果实现类只使用一次，就可以用匿名内部类简化代码\n```\n\n### 事件\n\n```\n事件源：\n\t按钮 图片 窗体...\n事件：某些操作\n\t如：鼠标单击，鼠标划入...\n绑定监听：\n\t当事件源上发生了某个事件，则执行某段代码\n\t\nKeryListener\n\t键盘监听\nMouseListener\n\t鼠标监听\n\t\t\t划入动作\n\t\t\t按下动作\n\t\t\t松开动作\n\t\t\thua'chu\nActionListener\n\t动作监听\n```\n\n### API\n\n#### BigInteger\n\n```\nBigInteger构造方法\t\t注意：对象一旦创建，内部的值不能发生改变\n\tpublic BigInteger(int num, Random rnd)\t\t获取随机大整数 范围：[0~2的num次方-1]\n\tpublic BigInteger(String val)\t\t\t\t获取指定的大整数\n\tpublic BigInteger(String val, int radix) \t获取指定进制的大整数\n\t\n\tpublic static BigInteger valueOf(long val)\t静态方法获取BigInteger的对象，内部有优化\n\t\n\tBigInteger构造方法小结\n\t\t如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取\n\t\t如果BigInteger表示的超出long的范围，可以用构造方法获取\n\t\t对象一旦创建，BigInteger内部记录的值不能发生改变\n\t\t只要进行计算都会产生一个新的BigInteger对象\n\t\t\nBigInteger成员方法\n\tpublic BigInteger add(BigInteger val)\t\t\t\t\t加法\n\tpublic BigInteger subtract(BigInteger val)\t\t\t\t减法\n\tpublic BigInteger multiply(BigInteger val)\t\t\t\t乘法\n\tpublic BigInteger divide(BigInteger val)\t\t\t\t除法，获取商\n\tpublic BigInteger divideAndRemainder(BigInteger val)\t除法，获取商和余数\n\tpublic BigInteger equals(Object x)\t\t\t\t\t\t比较是否相同\n\tpublic BigInteger pow(int exponent)\t\t\t\t\t\t次幂\n\tpublic BigInteger max/min(BigInteger val)\t\t\t\t返回较大值/较小值\n\tpublic int intValue(BigInteger val)\t\t\t\t\t\t转为int类型整数，超出范围数据有误\n```\n\n### 包装类\n\n```\n8种包装类中除了Character都有对应的parseXxx的方法进行类型\n```\n\n\n\n#### Integer\n\n```java\nInteger的成员方法\n\tpublic static String ToBinaryString(int i)\t\t\t得到二进制\n\tpublic static String ToOctalString(int i)\t\t\t得到八进制\n\tpublic static String ToHexString(int i)\t\t\t\t得到十六进制\n\tpublic static int parseInt(String s)\t\t\t\t将字符串类型的整数转成int类型的整数\n```\n\n### 快速排序\n\n```java\n第一轮：\n\t把0索引的数字作为基准数，确定基准数在数组中正确的位置。\n\t比基准数小的全部在左边，比基准数大的全部在右边。\n\t代码：\n    public static void quickSort(int[] arr, int i, int j) {\n        // 定义两个变量记录要查找的范围\n        int start = i;\n        int end = j;\n        //递归的出口\n        if (start > end){\n            return;\n        }\n        // 记录基准数的值\n        int baseNumber = arr[i];\n        // 利用循环找到要交换的数字   5   3  2  7  6\n        while (start != end) {\n            // 利用end，从后往前开始找，找比基准数小的数字\n            while (true) {\n                if (end <= start || arr[end] < baseNumber) {\n                    break;\n                }\n                end--;\n            }\n            // 利用start，从前往后找，找比基准数大的数字\n            while (true) {\n                if (start >= end || arr[start] > baseNumber) {\n                    break;\n                }\n                start++;\n            }\n            // 把end和start指向的元素进行交换\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n        }\n        // 当start和end指向了同一个元素的时候，那么上面的循环就会结束\n        // 表示已经找到了基准数在数组中应存的位置\n        // 基准数归位\n        //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换\n        int temp = arr[start];\n        arr[start] = baseNumber;\n        arr[i] = temp;\n        //确定6左边的范围，重复刚刚所做的事情\n        quickSort(arr,i,start-1);\n        //确定6右边的范围，重复刚刚所做的事情\n        quickSort(arr,start+1,j);\n    }\n\t\t\n```\n\n## 工具类\n\n### Arrays\n\n```\n操作数组的工具类：\npublic static String toString(数组)  把数组拼接成一个字符串\npublic static int binarySearch(数组,查找的元素)\t二分法查找元素\npublic static int[] copyOf(原数组, 新数组长度)\t拷贝数组\npublic static int[] copyOfRange(原数组,起始索引，结束索引)\t拷贝数组（指定范围）\npublic static void fill(数组,元素)\t填充数组\npublic static void sort(数组)\t按照默认方式进行数组排序\npublic static void sort(数组,排序规则)\t按照指定的规则排序\n```\n\n### 数据结构（红黑树）\n\n![Snipaste_2023-03-20_08-42-16](D:\\Users\\Mr.Q\\Pictures\\java\\Snipaste_2023-03-20_08-42-16.png)\n","tags":["小结、复习"]}]