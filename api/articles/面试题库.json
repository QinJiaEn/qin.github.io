{"title":"面试题库","slug":"面试题库","date":"2023-05-12T01:04:44.000Z","updated":"2023-05-16T01:50:00.320Z","comments":true,"path":"api/articles/面试题库.json","excerpt":null,"covers":["/posts/c5e9cf91/image-20220216222845410.png","/posts/c5e9cf91/image-20220205133550896.png","/posts/c5e9cf91/image-20220216224408053.png","/posts/c5e9cf91/image-20220205140202778.png","/posts/c5e9cf91/image-20220205141640067.png","/posts/c5e9cf91/image-20220205142506230.png","/posts/c5e9cf91/image-20220205143116277.png","/posts/c5e9cf91/image-20220205143213301.png","/posts/c5e9cf91/image-20220205143344612.png","/posts/c5e9cf91/image-20211121234732699.png","/posts/c5e9cf91/image-20211121234819672.png","/posts/c5e9cf91/image-20211121234902565.png","/posts/c5e9cf91/image-20211121235052820.png","/posts/c5e9cf91/image-20211121235346217.png","/posts/c5e9cf91/image-20211122221152776.png","/posts/c5e9cf91/image-20211122221255321.png","/posts/c5e9cf91/image-20220205135024347.png","/posts/c5e9cf91/image-20211122221623386.png","/posts/c5e9cf91/image-20211122221834107.png","/posts/c5e9cf91/image-20211122221953914.png","/posts/c5e9cf91/image-20211122222251802.png","/posts/c5e9cf91/image-20211122222552239.png","/images/image-20220205181209799.png","/posts/c5e9cf91/image-20220216235212123.png","/posts/c5e9cf91/1577331614462.png","/posts/c5e9cf91/image-20220205192109645.png","/posts/c5e9cf91/image-20220205192221590.png","/posts/c5e9cf91/image-20220205193256668.png","/posts/c5e9cf91/image-20220205193604548.png"],"content":"<h1 id=\"面试题小结\"><a href=\"#面试题小结\" class=\"headerlink\" title=\"面试题小结\"></a>面试题小结</h1><h1 id=\"1-内存结构\"><a href=\"#1-内存结构\" class=\"headerlink\" title=\"1 内存结构\"></a>1 内存结构</h1><blockquote>\n<h3 id=\"1、简述一下JVM的内存结构？-高频\"><a href=\"#1、简述一下JVM的内存结构？-高频\" class=\"headerlink\" title=\"1、简述一下JVM的内存结构？(高频)\"></a>1、简述一下JVM的内存结构？(高频)</h3></blockquote>\n<p>JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有</p>\n<p>区和共享区。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220216222845410.png\" alt=\"image-20220216222845410\" style=\"zoom: 50%;\"></th>\n</tr>\n</thead>\n</table>\n<p><strong>线程私有区</strong>：</p>\n<p>① 程序计数器</p>\n<ul>\n<li>作用：是一块较小的内存空间，可以理解为是当前线程所执行程序的字节码文件的行号指示器，存储的是当前线程所执行的<strong>行号</strong></li>\n<li>特点：线程私有 ，唯一一个不会出现内存溢出的内存空间</li>\n</ul>\n<p>② 虚拟机栈</p>\n<ul>\n<li><p>作用：管理JAVA方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法中变量的变量表、操作数栈、动态链接方法、返回值、返回地址</p>\n<p>等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205133550896.png\" alt=\"image-20220205133550896\"></th>\n</tr>\n</thead>\n</table>\n<ul>\n<li><p>特点：</p>\n<p>1、线程私有</p>\n<p>2、局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象引用（reference 类</p>\n<p>型）</p>\n<p>3、栈太小或者方法调用过深，都将抛出StackOverflowError异常</p>\n</li>\n<li><p>测试代码</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackDemo02</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录调用了多少次出现了栈内存溢出</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 入口方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            show() ;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;show方法被调用了:&quot;</span> + count + <span class=\"string\">&quot;次&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        count++ ;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;show方法执行了.....&quot;</span>);</span><br><span class=\"line\">        show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置虚拟机参数-Xss可以指定栈内存大小；例如：-Xss180k</p>\n<p>栈内存的默认值问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The <span class=\"keyword\">default</span> value depends on the platform: </span><br><span class=\"line\">* Linux/x64 (<span class=\"number\">64</span>-bit): <span class=\"number\">1024</span> KB </span><br><span class=\"line\">* macOS (<span class=\"number\">64</span>-bit): <span class=\"number\">1024</span> KB </span><br><span class=\"line\">* Oracle Solaris/x64 (<span class=\"number\">64</span>-bit): <span class=\"number\">1024</span> KB </span><br><span class=\"line\">* Windows: The <span class=\"keyword\">default</span> value depends on virtual memory</span><br></pre></td></tr></table></figure>\n\n<p>③ 本地方法栈：与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p>\n<p><strong>线程共享区</strong>：</p>\n<p>① 堆内存</p>\n<ul>\n<li>作用：是Java内存区域中一块用来存放对象实例的区域，新创建的对象，数组都使用堆内存；【从Java7开始，常量池也会使用堆内存】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220216224408053.png\" alt=\"image-20220216224408053\" style=\"zoom:50%;\"></th>\n</tr>\n</thead>\n</table>\n<p>Java 堆从GC的角度还可以细分为: 新生代( Eden区 、From Survivor区和 To Survivor区 )和老年代。</p>\n<ul>\n<li><p>特点：</p>\n<p>1、被线程共享，因此需要考虑线程安全问题</p>\n<p>2、会产生内存溢出问题</p>\n</li>\n<li><p>测试代码：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义一个变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建一个ArrayList对象</span></span><br><span class=\"line\">        ArrayList arrayList = <span class=\"keyword\">new</span> ArrayList() ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                arrayList.add(<span class=\"keyword\">new</span> Object()) ;</span><br><span class=\"line\">                count++ ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Throwable a) &#123;</span><br><span class=\"line\">            a.printStackTrace();</span><br><span class=\"line\">            <span class=\"comment\">// 输出程序执行的次数</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;总共执行了:&quot;</span> + count + <span class=\"string\">&quot;次&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>虚拟机参数：</li>\n</ul>\n<p>​\t-Xms\t设置最小堆内存大小(不能小于1024K); \t-Xms 堆内存初始大小，可以通过jmap工具进行查看</p>\n<p>​\t-Xmx\t设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看</p>\n<p>​\t例如：-Xms1024K -Xmx2048K</p>\n<p>② 方法区</p>\n<ul>\n<li><p>作用：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>\n</li>\n<li><p>特点：</p>\n<p>1、方法区是一块线程共享的内存区域</p>\n<p>2、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出的错误</p>\n<p>3、jdk1.6和jdk1.7方法区也常常被称之为永久区(永久代),大小一般都是几百兆；</p>\n<p>4、jdk1.8已经将方法区取消，替代的是元数据区(元空间),如果不指定大小，默认情况下，虚拟机会耗尽可用系统内存</p>\n<p>5、jdk7以后就将方法区中的常量池移动至<strong>堆内存</strong></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205140202778.png\" alt=\"image-20220205140202778\"></th>\n</tr>\n</thead>\n</table>\n<p>​\t变化的原因：</p>\n<p>​\t\t1、提高内存的回收效率(方法区内存的回收效率远远低于堆内存，因为方法去中存储的都是类信息，静态变量…这些信息不能被轻易回收)</p>\n<p>​\t\t2、字符串常量池在方法区，那么很容易产生内存溢出(因为方法区的垃圾回收效率比较低);</p>\n<ul>\n<li>测试代码</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\tjdk1.8的元数据区可以使用参数-XX:MaxMetaspaceSzie设定大小\t</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示元空间内存溢出</span></span><br><span class=\"line\"><span class=\"comment\"> * -XX:-UseCompressedClassPointers -XX:MaxMetaspaceSize=10m</span></span><br><span class=\"line\"><span class=\"comment\"> \tUseCompressedClassPointers使用指针压缩，如果不使用这个参数可能会出现: Compressed class space内存溢出</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxMetaspaceDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;\t\t\t\t<span class=\"comment\">// 当前这个类就是一个类加载器</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 定义变量，记录程序产生类的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            MaxMetaspaceDemo test = <span class=\"keyword\">new</span> MaxMetaspaceDemo();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++, j++) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 字节码写入器</span></span><br><span class=\"line\">                ClassWriter cw = <span class=\"keyword\">new</span> ClassWriter(<span class=\"number\">0</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 定义一个类版本为Opcodes.V1_1，它的访问域为public，名称为Class&#123;i&#125;,父类为java.lang.Object，不实现任何接口</span></span><br><span class=\"line\">                cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;Class&quot;</span> + i, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;java/lang/Object&quot;</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] code = cw.toByteArray();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 加载该类</span></span><br><span class=\"line\">                test.defineClass(<span class=\"string\">&quot;Class&quot;</span> + i, code, <span class=\"number\">0</span>, code.length);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"2、堆和栈的区别？-高频\"><a href=\"#2、堆和栈的区别？-高频\" class=\"headerlink\" title=\"2、堆和栈的区别？(高频)\"></a>2、堆和栈的区别？(高频)</h3></blockquote>\n<p>① 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储</p>\n<p>在堆内存中。</p>\n<p>② 共享性不同：栈内存是线程私有的。堆内存是所有线程共有的。</p>\n<p>③ 异常错误不同：如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：</p>\n<p>java.lang.OutOfMemoryError。</p>\n<p>④ 空间大小：栈的空间大小远远小于堆的。</p>\n<blockquote>\n<h3 id=\"3、怎么获取Java程序使用的内存？堆使用的百分比？\"><a href=\"#3、怎么获取Java程序使用的内存？堆使用的百分比？\" class=\"headerlink\" title=\"3、怎么获取Java程序使用的内存？堆使用的百分比？\"></a>3、怎么获取Java程序使用的内存？堆使用的百分比？</h3></blockquote>\n<p>可以通过java.lang.Runtime类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余</p>\n<p>空间。</p>\n<p>1、Runtime.freeMemory() 方法返回剩余空间的字节数</p>\n<p>2、Runtime.totalMemory()方法总内存的字节数</p>\n<blockquote>\n<h3 id=\"4、栈帧都有哪些数据？\"><a href=\"#4、栈帧都有哪些数据？\" class=\"headerlink\" title=\"4、栈帧都有哪些数据？\"></a>4、栈帧都有哪些数据？</h3></blockquote>\n<p>栈帧包含：局部变量表、操作数栈、动态连接、返回值、返回地址等。</p>\n<blockquote>\n<h3 id=\"5、如何启动系统的时候设置jvm的启动参数？\"><a href=\"#5、如何启动系统的时候设置jvm的启动参数？\" class=\"headerlink\" title=\"5、如何启动系统的时候设置jvm的启动参数？\"></a>5、如何启动系统的时候设置jvm的启动参数？</h3></blockquote>\n<p>其实都很简单，比如说采用”java -jar”的方式启动一个jar包里面的系统，那么就可以才用类似下面的格式：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205141640067.png\" alt=\"image-20220205141640067\"></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"2-垃圾回收\"><a href=\"#2-垃圾回收\" class=\"headerlink\" title=\"2 垃圾回收\"></a>2 垃圾回收</h1><blockquote>\n<h3 id=\"6、如何判断一个对象是否为垃圾？-高频\"><a href=\"#6、如何判断一个对象是否为垃圾？-高频\" class=\"headerlink\" title=\"6、如何判断一个对象是否为垃圾？(高频)\"></a>6、如何判断一个对象是否为垃圾？(高频)</h3></blockquote>\n<p>两种算法：</p>\n<p><strong>① 引用计数法</strong>：堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被</p>\n<p>赋值为这个对象的引用时，计数加1（a &#x3D; b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，</p>\n<p>对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。</p>\n<p>特点：简单、无法解决循环引用问题</p>\n<p>定义学生类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object instance ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写测试类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tjvm参数：-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</span></span><br><span class=\"line\"><span class=\"comment\">\t-verbose:gc -XX:+PrintGCDetails：打印gc日志信息</span></span><br><span class=\"line\"><span class=\"comment\">\t-XX:+PrintGCTimeStamps: 打印gc日志的时间戳</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountGcDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建Student对象</span></span><br><span class=\"line\">        Student a = <span class=\"keyword\">new</span> Student() ;</span><br><span class=\"line\">        Student b = <span class=\"keyword\">new</span> Student() ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 进行循环引用</span></span><br><span class=\"line\">        a.instance = b ;</span><br><span class=\"line\">        b.instance = a ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将a对象和b对象设置为null</span></span><br><span class=\"line\">        a = <span class=\"keyword\">null</span> ;</span><br><span class=\"line\">        b = <span class=\"keyword\">null</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用System.gc进行垃圾回收</span></span><br><span class=\"line\">        System.gc();                    <span class=\"comment\">// 如果没有触发垃圾回收说明Hotspot的jvm使用的就是引用计数法来判断对象是否为垃圾</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出gc日志:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.076</span>: [GC (System.gc()) [PSYoungGen: 7802K-&gt;856K(151552K)] 7802K-&gt;864K(498688K), <span class=\"number\">0.0008493</span> secs] [Times: user=<span class=\"number\">0.17</span> sys=<span class=\"number\">0.02</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.077</span>: [<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(System.gc()</span>) [PSYoungGen: 856K-&gt;0<span class=\"title\">K</span><span class=\"params\">(151552K)</span>] [ParOldGen: 8K-&gt;620<span class=\"title\">K</span><span class=\"params\">(347136K)</span>] 864K-&gt;620<span class=\"title\">K</span><span class=\"params\">(498688K)</span>, [Metaspace: 3356K-&gt;3356<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0044768 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 151552K, used 3901K [<span class=\"number\">0x0000000716c00000</span>, <span class=\"number\">0x0000000721500000</span>, <span class=\"number\">0x00000007c0000000</span>)</span><br><span class=\"line\">  eden space 130048K, <span class=\"number\">3</span>% used [<span class=\"number\">0x0000000716c00000</span>,<span class=\"number\">0x0000000716fcf748</span>,<span class=\"number\">0x000000071eb00000</span>)</span><br><span class=\"line\">  from space 21504K, <span class=\"number\">0</span>% used [<span class=\"number\">0x000000071eb00000</span>,<span class=\"number\">0x000000071eb00000</span>,<span class=\"number\">0x0000000720000000</span>)</span><br><span class=\"line\">  to   space 21504K, <span class=\"number\">0</span>% used [<span class=\"number\">0x0000000720000000</span>,<span class=\"number\">0x0000000720000000</span>,<span class=\"number\">0x0000000721500000</span>)</span><br><span class=\"line\"> ParOldGen       total 347136K, used 620K [<span class=\"number\">0x00000005c4400000</span>, <span class=\"number\">0x00000005d9700000</span>, <span class=\"number\">0x0000000716c00000</span>)</span><br><span class=\"line\">  object space 347136K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000005c4400000</span>,<span class=\"number\">0x00000005c449b318</span>,<span class=\"number\">0x00000005d9700000</span>)</span><br><span class=\"line\"> Metaspace       used 3365K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 370<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">① <span class=\"number\">0.076</span>: 代表gc发生的时间，从jvm启动以来经过的秒数</span><br><span class=\"line\">② [GC和[Full Gc: 说明这次垃圾收集器的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有<span class=\"string\">&quot;Full&quot;</span>，说明此次GC发生了stop-the-world。System.gc()是说明显示的调用了\t\t\t\t   System.gc方法进行垃圾回收</span><br><span class=\"line\">③ [PSYoungGen：表示GC发生的区域, 不同的垃圾收集器展示的区域名称不一样，PSYoungGen表示的是新生代，这里默认使用的是Parallel Scavenge收集器 (-XX:+UseSerialGC)</span><br><span class=\"line\">④ 7802K-&gt;856K(151552K)：GC前该区域已使用容量 -&gt; GC后该区域已使用容量(该区域的总容量)</span><br><span class=\"line\">⑤ 7802K-&gt;864K(498688K)：GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)</span><br><span class=\"line\">⑥ <span class=\"number\">0.0008493</span> secs：该区域GC所占用的时间</span><br><span class=\"line\">⑦ [Times: user=<span class=\"number\">0.17</span> sys=<span class=\"number\">0.02</span>, real=<span class=\"number\">0.00</span> secs]: 分别表示用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间(墙钟时间包括非运算的等待耗时)。多线程操作会叠加这些CPU时间，所以user、sys时间超过real时间是完全正常的。  </span><br></pre></td></tr></table></figure>\n\n<p><strong>② 可达性分析算法 <strong>： 可达性分析算法又叫做</strong>跟搜索法</strong>，就是通过一系列的称之为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的</p>\n<p>路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p>\n<p>(类似于葡萄串)；</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205142506230.png\" alt=\"image-20220205142506230\"></th>\n</tr>\n</thead>\n</table>\n<blockquote>\n<h3 id=\"7、可达性算法中，哪些对象可作为GC-Roots对象？-高频\"><a href=\"#7、可达性算法中，哪些对象可作为GC-Roots对象？-高频\" class=\"headerlink\" title=\"7、可达性算法中，哪些对象可作为GC Roots对象？(高频)\"></a>7、可达性算法中，哪些对象可作为GC Roots对象？(高频)</h3></blockquote>\n<p>可以作为GC ROOTS对象的情况：</p>\n<p>1、虚拟机栈中引用的对象</p>\n<p>2、方法区静态成员引用的对象</p>\n<p>3、方法区常量引用对象</p>\n<p>4、本地方法栈引用的对象</p>\n<blockquote>\n<h3 id=\"8、Java中都有哪些引用类型？-高频\"><a href=\"#8、Java中都有哪些引用类型？-高频\" class=\"headerlink\" title=\"8、Java中都有哪些引用类型？(高频)\"></a>8、Java中都有哪些引用类型？(高频)</h3></blockquote>\n<p><strong>① 强引用</strong></p>\n<p>Java中默认声明的就是强引用，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object(); <span class=\"comment\">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class=\"line\">obj = <span class=\"keyword\">null</span>;  <span class=\"comment\">//手动置null</span></span><br></pre></td></tr></table></figure>\n\n<p>只要<strong>强引用存在，垃圾回收器将永远不会回收被引用的对象</strong>，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引</p>\n<p>用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrongReferenceDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;() ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span> ;  x &lt; <span class=\"number\">10</span> ; x++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buff = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">1</span>];</span><br><span class=\"line\">            list.add(buff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>② 软引用</strong></p>\n<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回</strong></p>\n<p><strong>收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p>\n<p>在 JDK1.2 之后，用java.lang.ref.<strong>SoftReference</strong>类来表示软引用。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReferenceDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建数组对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span> ; x &lt; <span class=\"number\">10</span> ; x++) &#123;</span><br><span class=\"line\">            SoftReference&lt;<span class=\"keyword\">byte</span>[]&gt; softReference = <span class=\"keyword\">new</span> SoftReference&lt;<span class=\"keyword\">byte</span>[]&gt;(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">1</span>]) ;</span><br><span class=\"line\">            list.add(softReference) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();  <span class=\"comment\">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class=\"line\">            Object obj = ((SoftReference) list.get(i)).get();</span><br><span class=\"line\">            System.out.println(obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现无论循环创建多少个软引用对象，打印结果总是有一些为null，这里就说明了在内存不足的情况下，软引用将会被自动回收。</p>\n<p><strong>③ 弱引用</strong></p>\n<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2之后,用</p>\n<p>java.lang.ref.WeakReference来表示弱引用。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakReferenceDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建数组对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span> ; x &lt; <span class=\"number\">10</span> ; x++) &#123;</span><br><span class=\"line\">            WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt; weakReference = <span class=\"keyword\">new</span> WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt;(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">1</span>]) ;</span><br><span class=\"line\">            list.add(weakReference) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();  <span class=\"comment\">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class=\"line\">            Object obj = ((WeakReference) list.get(i)).get();</span><br><span class=\"line\">            System.out.println(obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>④ 虚引用</strong></p>\n<p>虚引用是最弱的一种引用关系，如果<strong>一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收</strong>，在 JDK1.2 之后，用 </p>\n<p>PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是</p>\n<p>说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns this reference object&#x27;s referent.  Because the referent of a</span></span><br><span class=\"line\"><span class=\"comment\">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>  &lt;code&gt;null&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a new phantom reference that refers to the given object and</span></span><br><span class=\"line\"><span class=\"comment\">     * is registered with the given queue.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * method will always return null and, since it does not have a queue, it</span></span><br><span class=\"line\"><span class=\"comment\">     * will never be enqueued.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> referent the object the new phantom reference will refer to</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class=\"line\"><span class=\"comment\">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<p>1、每次垃圾回收时都会被回收，主要用于监测对象是否已经从内存中删除</p>\n<p>2、虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中</p>\n<p>3、程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那</p>\n<p>么就可以在所引用的对象的内存被回收之前采取必要的行动</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReferenceDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建一个引用队列</span></span><br><span class=\"line\">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 创建一个虚引用，指向一个Object对象</span></span><br><span class=\"line\">        PhantomReference&lt;Object&gt; phantomReference = <span class=\"keyword\">new</span> PhantomReference&lt;Object&gt;(<span class=\"keyword\">new</span> Object(), referenceQueue);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从引用队列中获取元素, 该方法是阻塞方法</span></span><br><span class=\"line\">        System.out.println(referenceQueue.remove()); </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"9、常见的垃圾回收算法都有哪些？-高频\"><a href=\"#9、常见的垃圾回收算法都有哪些？-高频\" class=\"headerlink\" title=\"9、常见的垃圾回收算法都有哪些？(高频)\"></a>9、常见的垃圾回收算法都有哪些？(高频)</h3></blockquote>\n<p><strong>① 标记清除</strong></p>\n<p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205143116277.png\" alt=\"image-20220205143116277\"></th>\n</tr>\n</thead>\n</table>\n<p>优点：速度比较快</p>\n<p>缺点：会产生内存碎片，碎片过多，仍会使得连续空间少</p>\n<p><strong>② 标记整理</strong></p>\n<p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一进行整理，整理是指存活对象向一端移动来减少内存碎片，相对效率较低</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205143213301.png\" alt=\"image-20220205143213301\"></th>\n</tr>\n</thead>\n</table>\n<p>优点：无内存碎片</p>\n<p>缺点：效率较低</p>\n<p><strong>③ 复制算法</strong></p>\n<p>执行过程：开辟两份大小相等空间，一份空间始终空着，垃圾回收时，将存活对象拷贝进入空闲空间；</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205143344612.png\" alt=\"image-20220205143344612\"></th>\n</tr>\n</thead>\n</table>\n<p>优点：无内存碎片</p>\n<p>缺点：占用空间多</p>\n<p>注意：如果有很多对象的存活率较高，这时我们采用复制算法，那么效率就比较低；</p>\n<p><strong>④ 分代回收</strong></p>\n<p>概述：根据对象存活周期的不同，将对象划分为几块，比如Java的堆内存，分为新生代和老年代，然后根据各个年代的特点采用最合适的算法；</p>\n<p>新生代对象的存活的时间都比较短，因此使用的是【复制算法】；而老年代对象存活的时间比较长那么采用的就是【标记清除】或者【标记整理】；</p>\n<blockquote>\n<h3 id=\"10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？\"><a href=\"#10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？\" class=\"headerlink\" title=\"10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？\"></a>10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？</h3></blockquote>\n<p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下</p>\n<p>是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回</p>\n<p>收。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>\n<h1 id=\"3-对象分配\"><a href=\"#3-对象分配\" class=\"headerlink\" title=\"3 对象分配\"></a>3 对象分配</h1><blockquote>\n<h3 id=\"11、对象在内存中是如何进行分配的？-高频\"><a href=\"#11、对象在内存中是如何进行分配的？-高频\" class=\"headerlink\" title=\"11、对象在内存中是如何进行分配的？(高频)\"></a>11、对象在内存中是如何进行分配的？(高频)</h3></blockquote>\n<p><strong>① 对象优先在Eden分配</strong>：对象优先在『伊甸园』分配，当『伊甸园』没有足够的空间时，触发 ‘Minor GC’(小范围的GC)</p>\n<p>情况一：伊甸园的内存空间足够，不会发生’Minor GC’</p>\n<img src=\"/posts/c5e9cf91/image-20211121234732699.png\" alt=\"image-20211121234732699\" style=\"zoom: 50%;\"> \n\n<p>情况二：伊甸园的空间不够了</p>\n<img src=\"/posts/c5e9cf91/image-20211121234819672.png\" alt=\"image-20211121234819672\" style=\"zoom: 50%;\"> \n\n<p>垃圾回收线程启动，进行垃圾回收，此时会触发”stop the world”(停止所有用户线程)，</p>\n<img src=\"/posts/c5e9cf91/image-20211121234902565.png\" alt=\"image-20211121234902565\" style=\"zoom:50%;\"> \n\n<p>Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄最多到一定值(最大值是15，对</p>\n<p>象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁)(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有</p>\n<p>达到阈值的对象会被复制到“To”区域。</p>\n<img src=\"/posts/c5e9cf91/image-20211121235052820.png\" alt=\"image-20211121235052820\" style=\"zoom:50%;\"> \n\n<p>“From”和”To”会交换他们的角色,下一次垃圾回收的时候也是从Eden将存活的对象复制到TO区</p>\n<img src=\"/posts/c5e9cf91/image-20211121235346217.png\" alt=\"image-20211121235346217\" style=\"zoom:50%;\"> \n\n<p>Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>\n<p>案例演示：</p>\n<p>jvm参数设置：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>UseSerialGC <span class=\"operator\">-</span>verbose:gc <span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCDetails <span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCTimeStamps <span class=\"operator\">-</span>Xloggc:.<span class=\"operator\">/</span>gc.log <span class=\"operator\">-</span>Xms20M <span class=\"operator\">-</span>Xmx20M <span class=\"operator\">-</span>Xmn10M <span class=\"operator\">-</span>XX:SurvivorRatio<span class=\"operator\">=</span><span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>UseSerialGC 是指使用 Serial <span class=\"operator\">+</span> SerialOld 回收器组合</span><br><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCDetails <span class=\"operator\">-</span>verbose:gc 是指打印 GC 详细信息</span><br><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCTimeStamps 打印gc日志的时间戳</span><br><span class=\"line\"><span class=\"operator\">-</span>Xloggc:.<span class=\"operator\">/</span>gc.log 将gc日志输出到一个日志文件中</span><br><span class=\"line\"><span class=\"operator\">-</span>Xms20M <span class=\"operator\">-</span>Xmx20M <span class=\"operator\">-</span>Xmn10M 是指分配给JVM的最小，最大以及新生代内存</span><br><span class=\"line\"><span class=\"operator\">-</span>XX:SurvivorRatio<span class=\"operator\">=</span><span class=\"number\">8</span> 是指『伊甸园』与『幸存区 <span class=\"keyword\">From</span>』和『幸存区 <span class=\"keyword\">To</span>』比例为 <span class=\"number\">8</span>:<span class=\"number\">1</span>:<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>定义内存大小变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _512KB = <span class=\"number\">512</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _4MB = <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _7MB = <span class=\"number\">7</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _8MB = <span class=\"number\">8</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>案例1：没有创建数组对象，看参数运行情况</p>\n<p>案例2：创建一个4M的数组，查看内存分配情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个4M大小的数组</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_4MB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 8192K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K, <span class=\"number\">100</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>)  <span class=\"comment\">// 在伊甸园中创建对象</span></span><br><span class=\"line\">  from space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 0K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>没有触发GC操作，对象直接在Eden分配；</p>\n<p>案例3：创建一个7M的数组，查看内存分配情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个7M大小的数组</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_7MB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 触发垃圾回收</span><br><span class=\"line\">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class=\"number\">0.0023439</span> secs] 2004K-&gt;647K(19456K), <span class=\"number\">0.0024142</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 7897K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,  <span class=\"number\">88</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff314930</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,  <span class=\"number\">63</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff5a1e58</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 0K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>由于程序在启动的时候jdk内部还会存在一些对象的创建，因此当我们分配了一个7M的内存空间，eden内存不足，因此发生了一次Minor GC！并且将存</p>\n<p>活下的对象最终存储到from区中。</p>\n<p>案例4： 在案例3的基础上，在分配一个512KB的数组内存空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_7MB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 2005K-&gt;623K(9216K), <span class=\"number\">0.0015235</span> secs] 2005K-&gt;623K(19456K), <span class=\"number\">0.0015799</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 8713K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,  <span class=\"number\">98</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff3e6820</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,  <span class=\"number\">60</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff59bdb8</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 0K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br></pre></td></tr></table></figure>\n\n<p>触发一次GC操作！并且将存活下的对象最终存储到from区中，第二次分配_512KB大小的内存空间的时候，直接在伊甸园分配即可。</p>\n<p>案例5： 在4的基础上在分配一个512KB的数组内存空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_7MB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_512KB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes3 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 2004K-&gt;620K(9216K), <span class=\"number\">0.0018706</span> secs] 2004K-&gt;620K(19456K), <span class=\"number\">0.0019275</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [DefNew: 8628K-&gt;539K(9216K), <span class=\"number\">0.0063389</span> secs] 8628K-&gt;8323K(19456K), <span class=\"number\">0.0063773</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 1133K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,   <span class=\"number\">7</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000fec94930</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,  <span class=\"number\">52</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff486de0</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 7784K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,  <span class=\"number\">76</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffd9a040</span>, <span class=\"number\">0x00000000ffd9a200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>触发了2次垃圾回收！并且将from区中存活的对象存储到老年代！</p>\n<p><strong>② 大对象直接晋升至老年代</strong></p>\n<p>当对象太大，伊甸园包括幸存区都存放不下时，这时候老年代的连续空间足够，此对象会直接晋升至老年代，不会发生 GC</p>\n<img src=\"/posts/c5e9cf91/image-20211122221152776.png\" alt=\"image-20211122221152776\" style=\"zoom: 50%;\"> \n\n<p>结果</p>\n<img src=\"/posts/c5e9cf91/image-20211122221255321.png\" alt=\"image-20211122221255321\" style=\"zoom:50%;\"> \n\n\n\n<p>案例演示：</p>\n<p>案例1：直接分配一个8M的内存空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure>\n\n<p>伊甸园总大小只有 8 MB，但新分配的对象大小已经是 8MB，而幸存区都仅有 1MB，也无法容纳这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 2169K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,  <span class=\"number\">26</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000fee1e560</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 8192K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,  <span class=\"number\">80</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffe00010</span>, <span class=\"number\">0x00000000ffe00200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到结果并没有发生 GC，大对象直接被放入了老年代「tenured generation   total 10240K, used 8192K」</p>\n<p>案例演示2：老年代连续空间不足，触发 Full GC</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_8MB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure>\n\n<p>第一个 8MB 直接进入老年代，第二个 8MB 对象在分配时发现老年代空间不足，只好尝试先进行一次 Minor GC，结果发现新生代没有连续空间，只好</p>\n<p>触发一次 Full GC，最后发现老年代也没有连续空间，这时出现 OutOfMemoryError</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class=\"number\">0.0022693</span> secs][Tenured: 8192K-&gt;8838K(10240K), <span class=\"number\">0.0452151</span> secs] 10197K-&gt;8838K(19456K), [Metaspace: 3438K-&gt;3438K(1056768K)], <span class=\"number\">0.0504669</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.05</span> secs] </span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [TenuredException in thread &quot;main&quot; : 8838K-&gt;8820<span class=\"title\">K</span><span class=\"params\">(10240K)</span>, 0.0027463 secs] 8838K-&gt;8820<span class=\"title\">K</span><span class=\"params\">(19456K)</span>, [Metaspace: 3438K-&gt;3438<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0027877 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat com.itheima.jvm.gc.ObjectMemoryDemo.main(ObjectMemoryDemo.java:<span class=\"number\">14</span>)</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 246K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,   <span class=\"number\">3</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000fec3d890</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 8820K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,  <span class=\"number\">86</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffe9d220</span>, <span class=\"number\">0x00000000ffe9d400</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3470K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 379<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"12、对象是怎么从年轻代进入老年代的？\"><a href=\"#12、对象是怎么从年轻代进入老年代的？\" class=\"headerlink\" title=\"12、对象是怎么从年轻代进入老年代的？\"></a>12、对象是怎么从年轻代进入老年代的？</h3></blockquote>\n<p>存在3种情况：</p>\n<p>1、如果对象够老，会通过提升（Promotion）进入老年代，这一般是根据对象的年龄进行判断的。</p>\n<p>2、动态对象年龄判定。有的垃圾回收算法，比如G1，并不要求age必须达到15才能晋升到老年代，它会使用一些动态的计算方法。</p>\n<p>3、超出某个大小的对象将直接在老年代分配。不过这个值默认为0，意思是全部首选Eden区进行分配。</p>\n<blockquote>\n<h3 id=\"13、简单描述一下（分代）垃圾回收的过程？-高频\"><a href=\"#13、简单描述一下（分代）垃圾回收的过程？-高频\" class=\"headerlink\" title=\"13、简单描述一下（分代）垃圾回收的过程？(高频)\"></a>13、简单描述一下（分代）垃圾回收的过程？(高频)</h3></blockquote>\n<p><img src=\"/posts/c5e9cf91/image-20220205135024347.png\" alt=\"image-20220205135024347\"> </p>\n<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是2&#x2F;3。</p>\n<p>新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>\n<p>当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：</p>\n<p>1、在Eden区执行了第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称to）</p>\n<p>2、From区中的对象根据对象的年龄值决定去向，达到阈值15移动到老年代，没有达到复制到to区域(复制算法)</p>\n<p>3、在把Eden和to区中的对象清空掉</p>\n<blockquote>\n<h3 id=\"14、JVM的永久代中会发生垃圾回收么？\"><a href=\"#14、JVM的永久代中会发生垃圾回收么？\" class=\"headerlink\" title=\"14、JVM的永久代中会发生垃圾回收么？\"></a>14、JVM的永久代中会发生垃圾回收么？</h3></blockquote>\n<p>永久代会触发垃圾回收的，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。</p>\n<p>注：Java 8 中已经移除了永久代，新加了一个叫做元数据区(Metaspace)的内存区。</p>\n<h1 id=\"4-垃圾收集器\"><a href=\"#4-垃圾收集器\" class=\"headerlink\" title=\"4 垃圾收集器\"></a>4 垃圾收集器</h1><blockquote>\n<h3 id=\"15、常见的垃圾收集器都有哪些？-高频\"><a href=\"#15、常见的垃圾收集器都有哪些？-高频\" class=\"headerlink\" title=\"15、常见的垃圾收集器都有哪些？(高频)\"></a>15、常见的垃圾收集器都有哪些？(高频)</h3></blockquote>\n<p>常见的垃圾收集器如下所示：</p>\n<img src=\"/posts/c5e9cf91/image-20211122221623386.png\" alt=\"image-20211122221623386\" style=\"zoom:50%;\"> \n\n<p>不同的垃圾收集器，作用的堆内存空间是不一样的；上面的  serial ， parnew ， Paraller Scavenge 是新生代的垃圾回收</p>\n<p>器；CMS ， Serial Old ， </p>\n<p>Paralle Old是老年代的垃圾收集器 ， G1垃圾收集器可以作用于新生代和老年代； 连线表示垃圾收集器可以搭配使用；</p>\n<p><strong>① Serial</strong></p>\n<p>特点：</p>\n<ol>\n<li>Serial是一个单线程的垃圾收集器</li>\n<li>“Stop The World”，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。在用户不可见的情况下把用户正常工作的线程全部停掉。</li>\n</ol>\n<img src=\"/posts/c5e9cf91/image-20211122221834107.png\" alt=\"image-20211122221834107\" style=\"zoom:50%;\"> \n\n<p>应用场景：</p>\n<ol>\n<li>使用场景：多用于桌面应用，Client端的垃圾回收器</li>\n<li>桌面应用内存小，进行垃圾回收的时间比较短，只要不频繁发生停顿就可以接受</li>\n</ol>\n<p>Serial Old收集器是Serial的老年代版本和Serial一样是单线程，使用的算法是”标记-整理”</p>\n<p><strong>② ParNew</strong></p>\n<p>概述: ParNew 收集器其实就是 Serial 收集器的多线程版本</p>\n<img src=\"/posts/c5e9cf91/image-20211122221953914.png\" alt=\"image-20211122221953914\" style=\"zoom:50%;\"> \n\n<p>特点：</p>\n<p>1、会触发stop the world</p>\n<p>2、多线程方式进行垃圾回收</p>\n<p>应用场景：它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器</p>\n<p>注意：如果是单核cpu即使使用该垃圾回收器也无法提高执行效率</p>\n<p><strong>③ Parallel Scavenge</strong></p>\n<p>概述：Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p>\n<p>特点：由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器</p>\n<p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即<strong>吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）</strong>，虚拟</p>\n<p>机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%  </p>\n<p>应用场景： 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>\n<p>Parallel old收集器Parallel Scavenge收集器的老年代版本，使用多线程+标记整理算法</p>\n<p><strong>④ CMS(重点)</strong></p>\n<p>概述：CMS  (Concurrent Mark Sweep）收集器是-种以获取最短回收停顿时间为目标的收集器。</p>\n<p>特点：</p>\n<ol>\n<li><p>CMS 收集器是基于“标记-清除”算法实现的</p>\n</li>\n<li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好</p>\n<p>的体验。</p>\n</li>\n</ol>\n<img src=\"/posts/c5e9cf91/image-20211122222251802.png\" alt=\"image-20211122222251802\" style=\"zoom:50%;\"> \n\n\n\n<p>步骤流程：</p>\n<ul>\n<li>初始标记（CMS initial mark)  \t\t  ——– 标记一下 GC Roots 能直接关联到的对象，速度很快（stop the world）</li>\n<li>并发标记（CMS concurrent mark）  ——– 对初始标记标记过的对象，进行trace（进行追踪，得到所有关联的对象，进行标记）</li>\n<li>重新标记（CMS remark)                   ——– 为了修正并发标记期间因用户程序导致标记产生变动的标记记录（stop the world）</li>\n<li>并发清除（CMS concurrent sweep)</li>\n</ul>\n<p>缺点：会产生垃圾碎片</p>\n<p><strong>⑤ G1</strong></p>\n<p>概述： G1是一个分代的，并行与并发的”<strong>标记-整理</strong>“垃圾回收器。 它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂</p>\n<p>停时间（pause time），同时兼顾良好的吞吐量。</p>\n<p>相比于CMS：</p>\n<ol>\n<li><p>G1垃圾回收器使用的是”标记-整理”，因此其回收得到的空间是连续的。</p>\n</li>\n<li><p>G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内</p>\n<p>存的回收是以region作为基本单位的；</p>\n</li>\n</ol>\n<img src=\"/posts/c5e9cf91/image-20211122222552239.png\" alt=\"image-20211122222552239\" style=\"zoom:50%;\"> \n\n<blockquote>\n<h3 id=\"16、你都用过G1垃圾回收器的哪几个重要参数？\"><a href=\"#16、你都用过G1垃圾回收器的哪几个重要参数？\" class=\"headerlink\" title=\"16、你都用过G1垃圾回收器的哪几个重要参数？\"></a>16、你都用过G1垃圾回收器的哪几个重要参数？</h3></blockquote>\n<p><strong>① -XX:MaxGCPauseMillis</strong></p>\n<p>暂停时间，默认值200ms。这是一个软性目标，G1会尽量达成，如果达不成，会逐渐做自我调整。</p>\n<p><strong>② -XX:G1HeapRegionSize</strong></p>\n<p>Region大小，若未指定则默认最多生成2048块，每块的大小需要为2的幂次方，如1,2,4,8,16,32，最大值为32M。</p>\n<p><strong>③ -XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent</strong></p>\n<p>新生代比例有两个数值指定，下限：-XX:G1NewSizePercent，默认值5%，上限：-XX:G1MaxNewSizePercent，默认值60%。</p>\n<blockquote>\n<h3 id=\"17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？\"><a href=\"#17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？\" class=\"headerlink\" title=\"17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？\"></a>17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？</h3></blockquote>\n<p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 </p>\n<p>100M 左右的内存）就足够了。</p>\n<blockquote>\n<h3 id=\"18、生产上如何配置垃圾收集器的？\"><a href=\"#18、生产上如何配置垃圾收集器的？\" class=\"headerlink\" title=\"18、生产上如何配置垃圾收集器的？\"></a>18、生产上如何配置垃圾收集器的？</h3></blockquote>\n<table>\n<thead>\n<tr>\n<th><img src=\"/images/image-20220205181209799.png\" alt=\"image-20220205181209799\"></th>\n</tr>\n</thead>\n</table>\n<p>1、首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的2&#x2F;3（这是想</p>\n<p>给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。</p>\n<p>2、接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。</p>\n<p>3、再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。我会通过记录</p>\n<p>详细的GC日志，来找到这个瓶颈点，借用<strong>gceasy（重点）</strong><a href=\"https://gceasy.io/%E8%BF%99%E6%A0%B7%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%BE%88%E5%AE%B9%E6%98%93%E5%AE%9A%E4%BD%8D%E5%88%B0%E9%97%AE%E9%A2%98%E3%80%82%E4%B9%8B%E6%89%80%E4%BB%A5%E9%80%89%E6%8B%A9%E9%87%87%E7%94%A8%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%98%AF%E5%9B%A0\">https://gceasy.io/这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因</a></p>\n<p>为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。</p>\n<p><img src=\"/posts/c5e9cf91/image-20220216235212123.png\" alt=\"image-20220216235212123\"> </p>\n<h1 id=\"5-类加载器\"><a href=\"#5-类加载器\" class=\"headerlink\" title=\"5 类加载器\"></a>5 类加载器</h1><blockquote>\n<h3 id=\"19、什么是类加载器，类加载器有哪些？-高频\"><a href=\"#19、什么是类加载器，类加载器有哪些？-高频\" class=\"headerlink\" title=\"19、什么是类加载器，类加载器有哪些？(高频)\"></a>19、什么是类加载器，类加载器有哪些？(高频)</h3></blockquote>\n<p>类加载器的作用：负载将的class文件加载到java虚拟机中，并为之创建一个Class对象</p>\n<p>从Java虚拟机的角度来讲，只存在如下两种不同的类加载器：</p>\n<ol>\n<li>启动类加载器（Bootstrap ClassLoader）, 这个类加载器使用C++语言实现，是虚拟机自身的一部分</li>\n<li>其他类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类（java.lang.ClassLoader）</li>\n</ol>\n<p>从Java开发人员的角度来讲，类加载器还可以划分的更细致一下，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p>\n<ol>\n<li><p>启动类加载器（Bootstrap class loader）：它是虚拟机的内置类加载器，通过表示为null</p>\n</li>\n<li><p>平台类加载器（Platform class loader）  ：它是平台类加载器； 负责加载JDK中一些特殊的模块；</p>\n</li>\n<li><p>系统类加载器（System class loader）    ：它也被称为应用程序类加载器， 它负责加载用户类路径上所指定的类库，一般情况下这个就是程序中默</p>\n<p>认的类加载器</p>\n</li>\n</ol>\n<blockquote>\n<h3 id=\"20、Java的双亲委托机制是什么？-高频\"><a href=\"#20、Java的双亲委托机制是什么？-高频\" class=\"headerlink\" title=\"20、Java的双亲委托机制是什么？(高频)\"></a>20、Java的双亲委托机制是什么？(高频)</h3></blockquote>\n<p><strong>概述</strong></p>\n<p>我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的层次关系一般会如下图所</p>\n<p>示：</p>\n<img src=\"/posts/c5e9cf91/1577331614462.png\" alt=\"1577331614462\" style=\"zoom:33%;\">   \n\n<p>上图所展示的类加载器之间的这种层次关系，就称之为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该</p>\n<p>有自己的父类加载器。这里的类加载器的父子关系不是真正物理意义上的继承，而是逻辑上的继承。</p>\n<p><strong>工作过程</strong></p>\n<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个</p>\n<p>层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索</p>\n<p>返回中没有找到所需的类）时，子类加载器才会尝试自己去加载。</p>\n<h1 id=\"6-性能调优\"><a href=\"#6-性能调优\" class=\"headerlink\" title=\"6 性能调优\"></a>6 性能调优</h1><blockquote>\n<h3 id=\"21、调优命令有哪些？\"><a href=\"#21、调优命令有哪些？\" class=\"headerlink\" title=\"21、调优命令有哪些？\"></a>21、调优命令有哪些？</h3></blockquote>\n<p>1、<strong>jps</strong>，JVM Process Status Tool显示指定系统内所有的HotSpot虚拟机进程。</p>\n<p>2、<strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运</p>\n<p>行数据。</p>\n<p>查询帮助文档：jstat -options</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205192109645.png\" alt=\"image-20220205192109645\"></th>\n</tr>\n</thead>\n</table>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205192221590.png\" alt=\"image-20220205192221590\"></th>\n</tr>\n</thead>\n</table>\n<p>3、<strong>jmap</strong>，JVM Memory Map命令用于查看<strong>堆内存</strong>的分配情况以及生成heap dump文件 </p>\n<p>查询帮助文档：jmap -h</p>\n<p>示例1：jmap -heap 33193 查询堆内存的分配情况</p>\n<p>示例2：jmap -dump:format&#x3D;b,file&#x3D;thread-cup.log 33193</p>\n<p>4、<strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的</p>\n<p>分析结果后，可以在浏览器中查看</p>\n<p>查询帮助文档：</p>\n<p>jhat -h</p>\n<p>示例：jhat -J-Xmx512M thread-cup.log</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205193256668.png\" alt=\"image-20220205193256668\"></th>\n</tr>\n</thead>\n</table>\n<p>5、<strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。</p>\n<p>查看帮助文档：jstack -h</p>\n<p>示例：jstack -l 33193</p>\n<p>6、<strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p>\n<p>查看帮助文档：jinfo -h</p>\n<p>示例：jinfo -flags 33193</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205193604548.png\" alt=\"image-20220205193604548\"></th>\n</tr>\n</thead>\n</table>\n<blockquote>\n<h3 id=\"22、你知道哪些JVM性能调优参数？-高频\"><a href=\"#22、你知道哪些JVM性能调优参数？-高频\" class=\"headerlink\" title=\"22、你知道哪些JVM性能调优参数？(高频)\"></a>22、你知道哪些JVM性能调优参数？(高频)</h3></blockquote>\n<p>1、设定堆内存大小：</p>\n<p>​\t-Xms\t设置最小堆内存大小(不能小于1024K); \t-Xms 堆内存初始大小，可以通过jmap工具进行查看</p>\n<p>​\t-Xmx\t设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看</p>\n<p>2、设定新生代大小：</p>\n<p>​\t-XX:NewSize：新生代大小</p>\n<p>​\t-XX:NewRatio 新生代和老生代占比</p>\n<p>3、-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p>\n<p>4、设定垃圾回收器</p>\n<p>​\t年轻代用 -XX:+UseParNewGC </p>\n<p>​\t年老代用-XX:+UseConcMarkSweepGC</p>\n<blockquote>\n<h3 id=\"23、你用过哪些性能调优工具？-高频\"><a href=\"#23、你用过哪些性能调优工具？-高频\" class=\"headerlink\" title=\"23、你用过哪些性能调优工具？(高频)\"></a>23、你用过哪些性能调优工具？(高频)</h3></blockquote>\n<p>常用调优工具分为两类</p>\n<p>1、jdk自带监控工具</p>\n<ul>\n<li><p>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类</p>\n<p>等的监控</p>\n</li>\n<li><p>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</p>\n</li>\n</ul>\n<p>2、第三方</p>\n<ul>\n<li><p>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和</p>\n<p>减少内存消耗</p>\n</li>\n<li><p>GChisto，一款专业分析gc日志的工具</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"24、你都有哪些手段用来排查内存溢出？-高频\"><a href=\"#24、你都有哪些手段用来排查内存溢出？-高频\" class=\"headerlink\" title=\"24、你都有哪些手段用来排查内存溢出？(高频)\"></a>24、你都有哪些手段用来排查内存溢出？(高频)</h3></blockquote>\n<p>内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用<strong>jstat</strong>命令，发现Old区在一直增长。我使用</p>\n<p><strong>jmap</strong>命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学做缓</p>\n<p>存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 Guava Cache，并设置了弱引用，故障就消失了。</p>\n","more":"<h1 id=\"面试题小结\"><a href=\"#面试题小结\" class=\"headerlink\" title=\"面试题小结\"></a>面试题小结</h1><h1 id=\"1-内存结构\"><a href=\"#1-内存结构\" class=\"headerlink\" title=\"1 内存结构\"></a>1 内存结构</h1><blockquote>\n<h3 id=\"1、简述一下JVM的内存结构？-高频\"><a href=\"#1、简述一下JVM的内存结构？-高频\" class=\"headerlink\" title=\"1、简述一下JVM的内存结构？(高频)\"></a>1、简述一下JVM的内存结构？(高频)</h3></blockquote>\n<p>JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有</p>\n<p>区和共享区。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220216222845410.png\" alt=\"image-20220216222845410\" style=\"zoom: 50%;\"></th>\n</tr>\n</thead>\n</table>\n<p><strong>线程私有区</strong>：</p>\n<p>① 程序计数器</p>\n<ul>\n<li>作用：是一块较小的内存空间，可以理解为是当前线程所执行程序的字节码文件的行号指示器，存储的是当前线程所执行的<strong>行号</strong></li>\n<li>特点：线程私有 ，唯一一个不会出现内存溢出的内存空间</li>\n</ul>\n<p>② 虚拟机栈</p>\n<ul>\n<li><p>作用：管理JAVA方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法中变量的变量表、操作数栈、动态链接方法、返回值、返回地址</p>\n<p>等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205133550896.png\" alt=\"image-20220205133550896\"></th>\n</tr>\n</thead>\n</table>\n<ul>\n<li><p>特点：</p>\n<p>1、线程私有</p>\n<p>2、局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象引用（reference 类</p>\n<p>型）</p>\n<p>3、栈太小或者方法调用过深，都将抛出StackOverflowError异常</p>\n</li>\n<li><p>测试代码</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackDemo02</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录调用了多少次出现了栈内存溢出</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 入口方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            show() ;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;show方法被调用了:&quot;</span> + count + <span class=\"string\">&quot;次&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        count++ ;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;show方法执行了.....&quot;</span>);</span><br><span class=\"line\">        show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置虚拟机参数-Xss可以指定栈内存大小；例如：-Xss180k</p>\n<p>栈内存的默认值问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The <span class=\"keyword\">default</span> value depends on the platform: </span><br><span class=\"line\">* Linux/x64 (<span class=\"number\">64</span>-bit): <span class=\"number\">1024</span> KB </span><br><span class=\"line\">* macOS (<span class=\"number\">64</span>-bit): <span class=\"number\">1024</span> KB </span><br><span class=\"line\">* Oracle Solaris/x64 (<span class=\"number\">64</span>-bit): <span class=\"number\">1024</span> KB </span><br><span class=\"line\">* Windows: The <span class=\"keyword\">default</span> value depends on virtual memory</span><br></pre></td></tr></table></figure>\n\n<p>③ 本地方法栈：与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p>\n<p><strong>线程共享区</strong>：</p>\n<p>① 堆内存</p>\n<ul>\n<li>作用：是Java内存区域中一块用来存放对象实例的区域，新创建的对象，数组都使用堆内存；【从Java7开始，常量池也会使用堆内存】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220216224408053.png\" alt=\"image-20220216224408053\" style=\"zoom:50%;\"></th>\n</tr>\n</thead>\n</table>\n<p>Java 堆从GC的角度还可以细分为: 新生代( Eden区 、From Survivor区和 To Survivor区 )和老年代。</p>\n<ul>\n<li><p>特点：</p>\n<p>1、被线程共享，因此需要考虑线程安全问题</p>\n<p>2、会产生内存溢出问题</p>\n</li>\n<li><p>测试代码：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义一个变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建一个ArrayList对象</span></span><br><span class=\"line\">        ArrayList arrayList = <span class=\"keyword\">new</span> ArrayList() ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                arrayList.add(<span class=\"keyword\">new</span> Object()) ;</span><br><span class=\"line\">                count++ ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Throwable a) &#123;</span><br><span class=\"line\">            a.printStackTrace();</span><br><span class=\"line\">            <span class=\"comment\">// 输出程序执行的次数</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;总共执行了:&quot;</span> + count + <span class=\"string\">&quot;次&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>虚拟机参数：</li>\n</ul>\n<p>​\t-Xms\t设置最小堆内存大小(不能小于1024K); \t-Xms 堆内存初始大小，可以通过jmap工具进行查看</p>\n<p>​\t-Xmx\t设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看</p>\n<p>​\t例如：-Xms1024K -Xmx2048K</p>\n<p>② 方法区</p>\n<ul>\n<li><p>作用：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>\n</li>\n<li><p>特点：</p>\n<p>1、方法区是一块线程共享的内存区域</p>\n<p>2、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出的错误</p>\n<p>3、jdk1.6和jdk1.7方法区也常常被称之为永久区(永久代),大小一般都是几百兆；</p>\n<p>4、jdk1.8已经将方法区取消，替代的是元数据区(元空间),如果不指定大小，默认情况下，虚拟机会耗尽可用系统内存</p>\n<p>5、jdk7以后就将方法区中的常量池移动至<strong>堆内存</strong></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205140202778.png\" alt=\"image-20220205140202778\"></th>\n</tr>\n</thead>\n</table>\n<p>​\t变化的原因：</p>\n<p>​\t\t1、提高内存的回收效率(方法区内存的回收效率远远低于堆内存，因为方法去中存储的都是类信息，静态变量…这些信息不能被轻易回收)</p>\n<p>​\t\t2、字符串常量池在方法区，那么很容易产生内存溢出(因为方法区的垃圾回收效率比较低);</p>\n<ul>\n<li>测试代码</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\tjdk1.8的元数据区可以使用参数-XX:MaxMetaspaceSzie设定大小\t</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示元空间内存溢出</span></span><br><span class=\"line\"><span class=\"comment\"> * -XX:-UseCompressedClassPointers -XX:MaxMetaspaceSize=10m</span></span><br><span class=\"line\"><span class=\"comment\"> \tUseCompressedClassPointers使用指针压缩，如果不使用这个参数可能会出现: Compressed class space内存溢出</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxMetaspaceDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;\t\t\t\t<span class=\"comment\">// 当前这个类就是一个类加载器</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 定义变量，记录程序产生类的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            MaxMetaspaceDemo test = <span class=\"keyword\">new</span> MaxMetaspaceDemo();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++, j++) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 字节码写入器</span></span><br><span class=\"line\">                ClassWriter cw = <span class=\"keyword\">new</span> ClassWriter(<span class=\"number\">0</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 定义一个类版本为Opcodes.V1_1，它的访问域为public，名称为Class&#123;i&#125;,父类为java.lang.Object，不实现任何接口</span></span><br><span class=\"line\">                cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;Class&quot;</span> + i, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;java/lang/Object&quot;</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] code = cw.toByteArray();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 加载该类</span></span><br><span class=\"line\">                test.defineClass(<span class=\"string\">&quot;Class&quot;</span> + i, code, <span class=\"number\">0</span>, code.length);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"2、堆和栈的区别？-高频\"><a href=\"#2、堆和栈的区别？-高频\" class=\"headerlink\" title=\"2、堆和栈的区别？(高频)\"></a>2、堆和栈的区别？(高频)</h3></blockquote>\n<p>① 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储</p>\n<p>在堆内存中。</p>\n<p>② 共享性不同：栈内存是线程私有的。堆内存是所有线程共有的。</p>\n<p>③ 异常错误不同：如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：</p>\n<p>java.lang.OutOfMemoryError。</p>\n<p>④ 空间大小：栈的空间大小远远小于堆的。</p>\n<blockquote>\n<h3 id=\"3、怎么获取Java程序使用的内存？堆使用的百分比？\"><a href=\"#3、怎么获取Java程序使用的内存？堆使用的百分比？\" class=\"headerlink\" title=\"3、怎么获取Java程序使用的内存？堆使用的百分比？\"></a>3、怎么获取Java程序使用的内存？堆使用的百分比？</h3></blockquote>\n<p>可以通过java.lang.Runtime类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余</p>\n<p>空间。</p>\n<p>1、Runtime.freeMemory() 方法返回剩余空间的字节数</p>\n<p>2、Runtime.totalMemory()方法总内存的字节数</p>\n<blockquote>\n<h3 id=\"4、栈帧都有哪些数据？\"><a href=\"#4、栈帧都有哪些数据？\" class=\"headerlink\" title=\"4、栈帧都有哪些数据？\"></a>4、栈帧都有哪些数据？</h3></blockquote>\n<p>栈帧包含：局部变量表、操作数栈、动态连接、返回值、返回地址等。</p>\n<blockquote>\n<h3 id=\"5、如何启动系统的时候设置jvm的启动参数？\"><a href=\"#5、如何启动系统的时候设置jvm的启动参数？\" class=\"headerlink\" title=\"5、如何启动系统的时候设置jvm的启动参数？\"></a>5、如何启动系统的时候设置jvm的启动参数？</h3></blockquote>\n<p>其实都很简单，比如说采用”java -jar”的方式启动一个jar包里面的系统，那么就可以才用类似下面的格式：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205141640067.png\" alt=\"image-20220205141640067\"></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"2-垃圾回收\"><a href=\"#2-垃圾回收\" class=\"headerlink\" title=\"2 垃圾回收\"></a>2 垃圾回收</h1><blockquote>\n<h3 id=\"6、如何判断一个对象是否为垃圾？-高频\"><a href=\"#6、如何判断一个对象是否为垃圾？-高频\" class=\"headerlink\" title=\"6、如何判断一个对象是否为垃圾？(高频)\"></a>6、如何判断一个对象是否为垃圾？(高频)</h3></blockquote>\n<p>两种算法：</p>\n<p><strong>① 引用计数法</strong>：堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被</p>\n<p>赋值为这个对象的引用时，计数加1（a &#x3D; b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，</p>\n<p>对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。</p>\n<p>特点：简单、无法解决循环引用问题</p>\n<p>定义学生类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object instance ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写测试类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tjvm参数：-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</span></span><br><span class=\"line\"><span class=\"comment\">\t-verbose:gc -XX:+PrintGCDetails：打印gc日志信息</span></span><br><span class=\"line\"><span class=\"comment\">\t-XX:+PrintGCTimeStamps: 打印gc日志的时间戳</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountGcDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建Student对象</span></span><br><span class=\"line\">        Student a = <span class=\"keyword\">new</span> Student() ;</span><br><span class=\"line\">        Student b = <span class=\"keyword\">new</span> Student() ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 进行循环引用</span></span><br><span class=\"line\">        a.instance = b ;</span><br><span class=\"line\">        b.instance = a ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将a对象和b对象设置为null</span></span><br><span class=\"line\">        a = <span class=\"keyword\">null</span> ;</span><br><span class=\"line\">        b = <span class=\"keyword\">null</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用System.gc进行垃圾回收</span></span><br><span class=\"line\">        System.gc();                    <span class=\"comment\">// 如果没有触发垃圾回收说明Hotspot的jvm使用的就是引用计数法来判断对象是否为垃圾</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出gc日志:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.076</span>: [GC (System.gc()) [PSYoungGen: 7802K-&gt;856K(151552K)] 7802K-&gt;864K(498688K), <span class=\"number\">0.0008493</span> secs] [Times: user=<span class=\"number\">0.17</span> sys=<span class=\"number\">0.02</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.077</span>: [<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(System.gc()</span>) [PSYoungGen: 856K-&gt;0<span class=\"title\">K</span><span class=\"params\">(151552K)</span>] [ParOldGen: 8K-&gt;620<span class=\"title\">K</span><span class=\"params\">(347136K)</span>] 864K-&gt;620<span class=\"title\">K</span><span class=\"params\">(498688K)</span>, [Metaspace: 3356K-&gt;3356<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0044768 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 151552K, used 3901K [<span class=\"number\">0x0000000716c00000</span>, <span class=\"number\">0x0000000721500000</span>, <span class=\"number\">0x00000007c0000000</span>)</span><br><span class=\"line\">  eden space 130048K, <span class=\"number\">3</span>% used [<span class=\"number\">0x0000000716c00000</span>,<span class=\"number\">0x0000000716fcf748</span>,<span class=\"number\">0x000000071eb00000</span>)</span><br><span class=\"line\">  from space 21504K, <span class=\"number\">0</span>% used [<span class=\"number\">0x000000071eb00000</span>,<span class=\"number\">0x000000071eb00000</span>,<span class=\"number\">0x0000000720000000</span>)</span><br><span class=\"line\">  to   space 21504K, <span class=\"number\">0</span>% used [<span class=\"number\">0x0000000720000000</span>,<span class=\"number\">0x0000000720000000</span>,<span class=\"number\">0x0000000721500000</span>)</span><br><span class=\"line\"> ParOldGen       total 347136K, used 620K [<span class=\"number\">0x00000005c4400000</span>, <span class=\"number\">0x00000005d9700000</span>, <span class=\"number\">0x0000000716c00000</span>)</span><br><span class=\"line\">  object space 347136K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000005c4400000</span>,<span class=\"number\">0x00000005c449b318</span>,<span class=\"number\">0x00000005d9700000</span>)</span><br><span class=\"line\"> Metaspace       used 3365K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 370<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">① <span class=\"number\">0.076</span>: 代表gc发生的时间，从jvm启动以来经过的秒数</span><br><span class=\"line\">② [GC和[Full Gc: 说明这次垃圾收集器的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有<span class=\"string\">&quot;Full&quot;</span>，说明此次GC发生了stop-the-world。System.gc()是说明显示的调用了\t\t\t\t   System.gc方法进行垃圾回收</span><br><span class=\"line\">③ [PSYoungGen：表示GC发生的区域, 不同的垃圾收集器展示的区域名称不一样，PSYoungGen表示的是新生代，这里默认使用的是Parallel Scavenge收集器 (-XX:+UseSerialGC)</span><br><span class=\"line\">④ 7802K-&gt;856K(151552K)：GC前该区域已使用容量 -&gt; GC后该区域已使用容量(该区域的总容量)</span><br><span class=\"line\">⑤ 7802K-&gt;864K(498688K)：GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)</span><br><span class=\"line\">⑥ <span class=\"number\">0.0008493</span> secs：该区域GC所占用的时间</span><br><span class=\"line\">⑦ [Times: user=<span class=\"number\">0.17</span> sys=<span class=\"number\">0.02</span>, real=<span class=\"number\">0.00</span> secs]: 分别表示用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间(墙钟时间包括非运算的等待耗时)。多线程操作会叠加这些CPU时间，所以user、sys时间超过real时间是完全正常的。  </span><br></pre></td></tr></table></figure>\n\n<p><strong>② 可达性分析算法 <strong>： 可达性分析算法又叫做</strong>跟搜索法</strong>，就是通过一系列的称之为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的</p>\n<p>路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p>\n<p>(类似于葡萄串)；</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205142506230.png\" alt=\"image-20220205142506230\"></th>\n</tr>\n</thead>\n</table>\n<blockquote>\n<h3 id=\"7、可达性算法中，哪些对象可作为GC-Roots对象？-高频\"><a href=\"#7、可达性算法中，哪些对象可作为GC-Roots对象？-高频\" class=\"headerlink\" title=\"7、可达性算法中，哪些对象可作为GC Roots对象？(高频)\"></a>7、可达性算法中，哪些对象可作为GC Roots对象？(高频)</h3></blockquote>\n<p>可以作为GC ROOTS对象的情况：</p>\n<p>1、虚拟机栈中引用的对象</p>\n<p>2、方法区静态成员引用的对象</p>\n<p>3、方法区常量引用对象</p>\n<p>4、本地方法栈引用的对象</p>\n<blockquote>\n<h3 id=\"8、Java中都有哪些引用类型？-高频\"><a href=\"#8、Java中都有哪些引用类型？-高频\" class=\"headerlink\" title=\"8、Java中都有哪些引用类型？(高频)\"></a>8、Java中都有哪些引用类型？(高频)</h3></blockquote>\n<p><strong>① 强引用</strong></p>\n<p>Java中默认声明的就是强引用，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object(); <span class=\"comment\">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class=\"line\">obj = <span class=\"keyword\">null</span>;  <span class=\"comment\">//手动置null</span></span><br></pre></td></tr></table></figure>\n\n<p>只要<strong>强引用存在，垃圾回收器将永远不会回收被引用的对象</strong>，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引</p>\n<p>用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrongReferenceDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;() ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span> ;  x &lt; <span class=\"number\">10</span> ; x++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buff = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">1</span>];</span><br><span class=\"line\">            list.add(buff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>② 软引用</strong></p>\n<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回</strong></p>\n<p><strong>收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p>\n<p>在 JDK1.2 之后，用java.lang.ref.<strong>SoftReference</strong>类来表示软引用。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReferenceDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建数组对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span> ; x &lt; <span class=\"number\">10</span> ; x++) &#123;</span><br><span class=\"line\">            SoftReference&lt;<span class=\"keyword\">byte</span>[]&gt; softReference = <span class=\"keyword\">new</span> SoftReference&lt;<span class=\"keyword\">byte</span>[]&gt;(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">1</span>]) ;</span><br><span class=\"line\">            list.add(softReference) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();  <span class=\"comment\">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class=\"line\">            Object obj = ((SoftReference) list.get(i)).get();</span><br><span class=\"line\">            System.out.println(obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现无论循环创建多少个软引用对象，打印结果总是有一些为null，这里就说明了在内存不足的情况下，软引用将会被自动回收。</p>\n<p><strong>③ 弱引用</strong></p>\n<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2之后,用</p>\n<p>java.lang.ref.WeakReference来表示弱引用。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakReferenceDemo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建数组对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span> ; x &lt; <span class=\"number\">10</span> ; x++) &#123;</span><br><span class=\"line\">            WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt; weakReference = <span class=\"keyword\">new</span> WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt;(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">1</span>]) ;</span><br><span class=\"line\">            list.add(weakReference) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();  <span class=\"comment\">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class=\"line\">            Object obj = ((WeakReference) list.get(i)).get();</span><br><span class=\"line\">            System.out.println(obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>④ 虚引用</strong></p>\n<p>虚引用是最弱的一种引用关系，如果<strong>一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收</strong>，在 JDK1.2 之后，用 </p>\n<p>PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是</p>\n<p>说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns this reference object&#x27;s referent.  Because the referent of a</span></span><br><span class=\"line\"><span class=\"comment\">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>  &lt;code&gt;null&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a new phantom reference that refers to the given object and</span></span><br><span class=\"line\"><span class=\"comment\">     * is registered with the given queue.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * method will always return null and, since it does not have a queue, it</span></span><br><span class=\"line\"><span class=\"comment\">     * will never be enqueued.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> referent the object the new phantom reference will refer to</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class=\"line\"><span class=\"comment\">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<p>1、每次垃圾回收时都会被回收，主要用于监测对象是否已经从内存中删除</p>\n<p>2、虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中</p>\n<p>3、程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那</p>\n<p>么就可以在所引用的对象的内存被回收之前采取必要的行动</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReferenceDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建一个引用队列</span></span><br><span class=\"line\">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 创建一个虚引用，指向一个Object对象</span></span><br><span class=\"line\">        PhantomReference&lt;Object&gt; phantomReference = <span class=\"keyword\">new</span> PhantomReference&lt;Object&gt;(<span class=\"keyword\">new</span> Object(), referenceQueue);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从引用队列中获取元素, 该方法是阻塞方法</span></span><br><span class=\"line\">        System.out.println(referenceQueue.remove()); </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"9、常见的垃圾回收算法都有哪些？-高频\"><a href=\"#9、常见的垃圾回收算法都有哪些？-高频\" class=\"headerlink\" title=\"9、常见的垃圾回收算法都有哪些？(高频)\"></a>9、常见的垃圾回收算法都有哪些？(高频)</h3></blockquote>\n<p><strong>① 标记清除</strong></p>\n<p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205143116277.png\" alt=\"image-20220205143116277\"></th>\n</tr>\n</thead>\n</table>\n<p>优点：速度比较快</p>\n<p>缺点：会产生内存碎片，碎片过多，仍会使得连续空间少</p>\n<p><strong>② 标记整理</strong></p>\n<p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一进行整理，整理是指存活对象向一端移动来减少内存碎片，相对效率较低</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205143213301.png\" alt=\"image-20220205143213301\"></th>\n</tr>\n</thead>\n</table>\n<p>优点：无内存碎片</p>\n<p>缺点：效率较低</p>\n<p><strong>③ 复制算法</strong></p>\n<p>执行过程：开辟两份大小相等空间，一份空间始终空着，垃圾回收时，将存活对象拷贝进入空闲空间；</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205143344612.png\" alt=\"image-20220205143344612\"></th>\n</tr>\n</thead>\n</table>\n<p>优点：无内存碎片</p>\n<p>缺点：占用空间多</p>\n<p>注意：如果有很多对象的存活率较高，这时我们采用复制算法，那么效率就比较低；</p>\n<p><strong>④ 分代回收</strong></p>\n<p>概述：根据对象存活周期的不同，将对象划分为几块，比如Java的堆内存，分为新生代和老年代，然后根据各个年代的特点采用最合适的算法；</p>\n<p>新生代对象的存活的时间都比较短，因此使用的是【复制算法】；而老年代对象存活的时间比较长那么采用的就是【标记清除】或者【标记整理】；</p>\n<blockquote>\n<h3 id=\"10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？\"><a href=\"#10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？\" class=\"headerlink\" title=\"10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？\"></a>10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？</h3></blockquote>\n<p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下</p>\n<p>是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回</p>\n<p>收。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>\n<h1 id=\"3-对象分配\"><a href=\"#3-对象分配\" class=\"headerlink\" title=\"3 对象分配\"></a>3 对象分配</h1><blockquote>\n<h3 id=\"11、对象在内存中是如何进行分配的？-高频\"><a href=\"#11、对象在内存中是如何进行分配的？-高频\" class=\"headerlink\" title=\"11、对象在内存中是如何进行分配的？(高频)\"></a>11、对象在内存中是如何进行分配的？(高频)</h3></blockquote>\n<p><strong>① 对象优先在Eden分配</strong>：对象优先在『伊甸园』分配，当『伊甸园』没有足够的空间时，触发 ‘Minor GC’(小范围的GC)</p>\n<p>情况一：伊甸园的内存空间足够，不会发生’Minor GC’</p>\n<img src=\"/posts/c5e9cf91/image-20211121234732699.png\" alt=\"image-20211121234732699\" style=\"zoom: 50%;\"> \n\n<p>情况二：伊甸园的空间不够了</p>\n<img src=\"/posts/c5e9cf91/image-20211121234819672.png\" alt=\"image-20211121234819672\" style=\"zoom: 50%;\"> \n\n<p>垃圾回收线程启动，进行垃圾回收，此时会触发”stop the world”(停止所有用户线程)，</p>\n<img src=\"/posts/c5e9cf91/image-20211121234902565.png\" alt=\"image-20211121234902565\" style=\"zoom:50%;\"> \n\n<p>Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄最多到一定值(最大值是15，对</p>\n<p>象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁)(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有</p>\n<p>达到阈值的对象会被复制到“To”区域。</p>\n<img src=\"/posts/c5e9cf91/image-20211121235052820.png\" alt=\"image-20211121235052820\" style=\"zoom:50%;\"> \n\n<p>“From”和”To”会交换他们的角色,下一次垃圾回收的时候也是从Eden将存活的对象复制到TO区</p>\n<img src=\"/posts/c5e9cf91/image-20211121235346217.png\" alt=\"image-20211121235346217\" style=\"zoom:50%;\"> \n\n<p>Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>\n<p>案例演示：</p>\n<p>jvm参数设置：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>UseSerialGC <span class=\"operator\">-</span>verbose:gc <span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCDetails <span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCTimeStamps <span class=\"operator\">-</span>Xloggc:.<span class=\"operator\">/</span>gc.log <span class=\"operator\">-</span>Xms20M <span class=\"operator\">-</span>Xmx20M <span class=\"operator\">-</span>Xmn10M <span class=\"operator\">-</span>XX:SurvivorRatio<span class=\"operator\">=</span><span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>UseSerialGC 是指使用 Serial <span class=\"operator\">+</span> SerialOld 回收器组合</span><br><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCDetails <span class=\"operator\">-</span>verbose:gc 是指打印 GC 详细信息</span><br><span class=\"line\"><span class=\"operator\">-</span>XX:<span class=\"operator\">+</span>PrintGCTimeStamps 打印gc日志的时间戳</span><br><span class=\"line\"><span class=\"operator\">-</span>Xloggc:.<span class=\"operator\">/</span>gc.log 将gc日志输出到一个日志文件中</span><br><span class=\"line\"><span class=\"operator\">-</span>Xms20M <span class=\"operator\">-</span>Xmx20M <span class=\"operator\">-</span>Xmn10M 是指分配给JVM的最小，最大以及新生代内存</span><br><span class=\"line\"><span class=\"operator\">-</span>XX:SurvivorRatio<span class=\"operator\">=</span><span class=\"number\">8</span> 是指『伊甸园』与『幸存区 <span class=\"keyword\">From</span>』和『幸存区 <span class=\"keyword\">To</span>』比例为 <span class=\"number\">8</span>:<span class=\"number\">1</span>:<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>定义内存大小变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _512KB = <span class=\"number\">512</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _4MB = <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _7MB = <span class=\"number\">7</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _8MB = <span class=\"number\">8</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>案例1：没有创建数组对象，看参数运行情况</p>\n<p>案例2：创建一个4M的数组，查看内存分配情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个4M大小的数组</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_4MB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 8192K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K, <span class=\"number\">100</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>)  <span class=\"comment\">// 在伊甸园中创建对象</span></span><br><span class=\"line\">  from space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 0K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>没有触发GC操作，对象直接在Eden分配；</p>\n<p>案例3：创建一个7M的数组，查看内存分配情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个7M大小的数组</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_7MB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 触发垃圾回收</span><br><span class=\"line\">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class=\"number\">0.0023439</span> secs] 2004K-&gt;647K(19456K), <span class=\"number\">0.0024142</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 7897K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,  <span class=\"number\">88</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff314930</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,  <span class=\"number\">63</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff5a1e58</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 0K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>由于程序在启动的时候jdk内部还会存在一些对象的创建，因此当我们分配了一个7M的内存空间，eden内存不足，因此发生了一次Minor GC！并且将存</p>\n<p>活下的对象最终存储到from区中。</p>\n<p>案例4： 在案例3的基础上，在分配一个512KB的数组内存空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_7MB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 2005K-&gt;623K(9216K), <span class=\"number\">0.0015235</span> secs] 2005K-&gt;623K(19456K), <span class=\"number\">0.0015799</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 8713K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,  <span class=\"number\">98</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff3e6820</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,  <span class=\"number\">60</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff59bdb8</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 0K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br></pre></td></tr></table></figure>\n\n<p>触发一次GC操作！并且将存活下的对象最终存储到from区中，第二次分配_512KB大小的内存空间的时候，直接在伊甸园分配即可。</p>\n<p>案例5： 在4的基础上在分配一个512KB的数组内存空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_7MB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_512KB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes3 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 2004K-&gt;620K(9216K), <span class=\"number\">0.0018706</span> secs] 2004K-&gt;620K(19456K), <span class=\"number\">0.0019275</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [DefNew: 8628K-&gt;539K(9216K), <span class=\"number\">0.0063389</span> secs] 8628K-&gt;8323K(19456K), <span class=\"number\">0.0063773</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 1133K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,   <span class=\"number\">7</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000fec94930</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,  <span class=\"number\">52</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff486de0</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 7784K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,  <span class=\"number\">76</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffd9a040</span>, <span class=\"number\">0x00000000ffd9a200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>触发了2次垃圾回收！并且将from区中存活的对象存储到老年代！</p>\n<p><strong>② 大对象直接晋升至老年代</strong></p>\n<p>当对象太大，伊甸园包括幸存区都存放不下时，这时候老年代的连续空间足够，此对象会直接晋升至老年代，不会发生 GC</p>\n<img src=\"/posts/c5e9cf91/image-20211122221152776.png\" alt=\"image-20211122221152776\" style=\"zoom: 50%;\"> \n\n<p>结果</p>\n<img src=\"/posts/c5e9cf91/image-20211122221255321.png\" alt=\"image-20211122221255321\" style=\"zoom:50%;\"> \n\n\n\n<p>案例演示：</p>\n<p>案例1：直接分配一个8M的内存空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure>\n\n<p>伊甸园总大小只有 8 MB，但新分配的对象大小已经是 8MB，而幸存区都仅有 1MB，也无法容纳这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 2169K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,  <span class=\"number\">26</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000fee1e560</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 8192K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,  <span class=\"number\">80</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffe00010</span>, <span class=\"number\">0x00000000ffe00200</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 376<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到结果并没有发生 GC，大对象直接被放入了老年代「tenured generation   total 10240K, used 8192K」</p>\n<p>案例演示2：老年代连续空间不足，触发 Full GC</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_8MB] ;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure>\n\n<p>第一个 8MB 直接进入老年代，第二个 8MB 对象在分配时发现老年代空间不足，只好尝试先进行一次 Minor GC，结果发现新生代没有连续空间，只好</p>\n<p>触发一次 Full GC，最后发现老年代也没有连续空间，这时出现 OutOfMemoryError</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class=\"number\">0.0022693</span> secs][Tenured: 8192K-&gt;8838K(10240K), <span class=\"number\">0.0452151</span> secs] 10197K-&gt;8838K(19456K), [Metaspace: 3438K-&gt;3438K(1056768K)], <span class=\"number\">0.0504669</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.05</span> secs] </span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [TenuredException in thread &quot;main&quot; : 8838K-&gt;8820<span class=\"title\">K</span><span class=\"params\">(10240K)</span>, 0.0027463 secs] 8838K-&gt;8820<span class=\"title\">K</span><span class=\"params\">(19456K)</span>, [Metaspace: 3438K-&gt;3438<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0027877 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat com.itheima.jvm.gc.ObjectMemoryDemo.main(ObjectMemoryDemo.java:<span class=\"number\">14</span>)</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def <span class=\"keyword\">new</span> generation   total 9216K, used 246K [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  eden space 8192K,   <span class=\"number\">3</span>% used [<span class=\"number\">0x00000000fec00000</span>, <span class=\"number\">0x00000000fec3d890</span>, <span class=\"number\">0x00000000ff400000</span>)</span><br><span class=\"line\">  from space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff500000</span>, <span class=\"number\">0x00000000ff600000</span>)</span><br><span class=\"line\">  to   space 1024K,   <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff400000</span>, <span class=\"number\">0x00000000ff500000</span>)</span><br><span class=\"line\"> tenured generation   total 10240K, used 8820K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">   the space 10240K,  <span class=\"number\">86</span>% used [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffe9d220</span>, <span class=\"number\">0x00000000ffe9d400</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> Metaspace       used 3470K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 379<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 388<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h3 id=\"12、对象是怎么从年轻代进入老年代的？\"><a href=\"#12、对象是怎么从年轻代进入老年代的？\" class=\"headerlink\" title=\"12、对象是怎么从年轻代进入老年代的？\"></a>12、对象是怎么从年轻代进入老年代的？</h3></blockquote>\n<p>存在3种情况：</p>\n<p>1、如果对象够老，会通过提升（Promotion）进入老年代，这一般是根据对象的年龄进行判断的。</p>\n<p>2、动态对象年龄判定。有的垃圾回收算法，比如G1，并不要求age必须达到15才能晋升到老年代，它会使用一些动态的计算方法。</p>\n<p>3、超出某个大小的对象将直接在老年代分配。不过这个值默认为0，意思是全部首选Eden区进行分配。</p>\n<blockquote>\n<h3 id=\"13、简单描述一下（分代）垃圾回收的过程？-高频\"><a href=\"#13、简单描述一下（分代）垃圾回收的过程？-高频\" class=\"headerlink\" title=\"13、简单描述一下（分代）垃圾回收的过程？(高频)\"></a>13、简单描述一下（分代）垃圾回收的过程？(高频)</h3></blockquote>\n<p><img src=\"/posts/c5e9cf91/image-20220205135024347.png\" alt=\"image-20220205135024347\"> </p>\n<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是2&#x2F;3。</p>\n<p>新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>\n<p>当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：</p>\n<p>1、在Eden区执行了第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称to）</p>\n<p>2、From区中的对象根据对象的年龄值决定去向，达到阈值15移动到老年代，没有达到复制到to区域(复制算法)</p>\n<p>3、在把Eden和to区中的对象清空掉</p>\n<blockquote>\n<h3 id=\"14、JVM的永久代中会发生垃圾回收么？\"><a href=\"#14、JVM的永久代中会发生垃圾回收么？\" class=\"headerlink\" title=\"14、JVM的永久代中会发生垃圾回收么？\"></a>14、JVM的永久代中会发生垃圾回收么？</h3></blockquote>\n<p>永久代会触发垃圾回收的，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。</p>\n<p>注：Java 8 中已经移除了永久代，新加了一个叫做元数据区(Metaspace)的内存区。</p>\n<h1 id=\"4-垃圾收集器\"><a href=\"#4-垃圾收集器\" class=\"headerlink\" title=\"4 垃圾收集器\"></a>4 垃圾收集器</h1><blockquote>\n<h3 id=\"15、常见的垃圾收集器都有哪些？-高频\"><a href=\"#15、常见的垃圾收集器都有哪些？-高频\" class=\"headerlink\" title=\"15、常见的垃圾收集器都有哪些？(高频)\"></a>15、常见的垃圾收集器都有哪些？(高频)</h3></blockquote>\n<p>常见的垃圾收集器如下所示：</p>\n<img src=\"/posts/c5e9cf91/image-20211122221623386.png\" alt=\"image-20211122221623386\" style=\"zoom:50%;\"> \n\n<p>不同的垃圾收集器，作用的堆内存空间是不一样的；上面的  serial ， parnew ， Paraller Scavenge 是新生代的垃圾回收</p>\n<p>器；CMS ， Serial Old ， </p>\n<p>Paralle Old是老年代的垃圾收集器 ， G1垃圾收集器可以作用于新生代和老年代； 连线表示垃圾收集器可以搭配使用；</p>\n<p><strong>① Serial</strong></p>\n<p>特点：</p>\n<ol>\n<li>Serial是一个单线程的垃圾收集器</li>\n<li>“Stop The World”，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。在用户不可见的情况下把用户正常工作的线程全部停掉。</li>\n</ol>\n<img src=\"/posts/c5e9cf91/image-20211122221834107.png\" alt=\"image-20211122221834107\" style=\"zoom:50%;\"> \n\n<p>应用场景：</p>\n<ol>\n<li>使用场景：多用于桌面应用，Client端的垃圾回收器</li>\n<li>桌面应用内存小，进行垃圾回收的时间比较短，只要不频繁发生停顿就可以接受</li>\n</ol>\n<p>Serial Old收集器是Serial的老年代版本和Serial一样是单线程，使用的算法是”标记-整理”</p>\n<p><strong>② ParNew</strong></p>\n<p>概述: ParNew 收集器其实就是 Serial 收集器的多线程版本</p>\n<img src=\"/posts/c5e9cf91/image-20211122221953914.png\" alt=\"image-20211122221953914\" style=\"zoom:50%;\"> \n\n<p>特点：</p>\n<p>1、会触发stop the world</p>\n<p>2、多线程方式进行垃圾回收</p>\n<p>应用场景：它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器</p>\n<p>注意：如果是单核cpu即使使用该垃圾回收器也无法提高执行效率</p>\n<p><strong>③ Parallel Scavenge</strong></p>\n<p>概述：Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p>\n<p>特点：由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器</p>\n<p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即<strong>吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）</strong>，虚拟</p>\n<p>机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%  </p>\n<p>应用场景： 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>\n<p>Parallel old收集器Parallel Scavenge收集器的老年代版本，使用多线程+标记整理算法</p>\n<p><strong>④ CMS(重点)</strong></p>\n<p>概述：CMS  (Concurrent Mark Sweep）收集器是-种以获取最短回收停顿时间为目标的收集器。</p>\n<p>特点：</p>\n<ol>\n<li><p>CMS 收集器是基于“标记-清除”算法实现的</p>\n</li>\n<li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好</p>\n<p>的体验。</p>\n</li>\n</ol>\n<img src=\"/posts/c5e9cf91/image-20211122222251802.png\" alt=\"image-20211122222251802\" style=\"zoom:50%;\"> \n\n\n\n<p>步骤流程：</p>\n<ul>\n<li>初始标记（CMS initial mark)  \t\t  ——– 标记一下 GC Roots 能直接关联到的对象，速度很快（stop the world）</li>\n<li>并发标记（CMS concurrent mark）  ——– 对初始标记标记过的对象，进行trace（进行追踪，得到所有关联的对象，进行标记）</li>\n<li>重新标记（CMS remark)                   ——– 为了修正并发标记期间因用户程序导致标记产生变动的标记记录（stop the world）</li>\n<li>并发清除（CMS concurrent sweep)</li>\n</ul>\n<p>缺点：会产生垃圾碎片</p>\n<p><strong>⑤ G1</strong></p>\n<p>概述： G1是一个分代的，并行与并发的”<strong>标记-整理</strong>“垃圾回收器。 它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂</p>\n<p>停时间（pause time），同时兼顾良好的吞吐量。</p>\n<p>相比于CMS：</p>\n<ol>\n<li><p>G1垃圾回收器使用的是”标记-整理”，因此其回收得到的空间是连续的。</p>\n</li>\n<li><p>G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内</p>\n<p>存的回收是以region作为基本单位的；</p>\n</li>\n</ol>\n<img src=\"/posts/c5e9cf91/image-20211122222552239.png\" alt=\"image-20211122222552239\" style=\"zoom:50%;\"> \n\n<blockquote>\n<h3 id=\"16、你都用过G1垃圾回收器的哪几个重要参数？\"><a href=\"#16、你都用过G1垃圾回收器的哪几个重要参数？\" class=\"headerlink\" title=\"16、你都用过G1垃圾回收器的哪几个重要参数？\"></a>16、你都用过G1垃圾回收器的哪几个重要参数？</h3></blockquote>\n<p><strong>① -XX:MaxGCPauseMillis</strong></p>\n<p>暂停时间，默认值200ms。这是一个软性目标，G1会尽量达成，如果达不成，会逐渐做自我调整。</p>\n<p><strong>② -XX:G1HeapRegionSize</strong></p>\n<p>Region大小，若未指定则默认最多生成2048块，每块的大小需要为2的幂次方，如1,2,4,8,16,32，最大值为32M。</p>\n<p><strong>③ -XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent</strong></p>\n<p>新生代比例有两个数值指定，下限：-XX:G1NewSizePercent，默认值5%，上限：-XX:G1MaxNewSizePercent，默认值60%。</p>\n<blockquote>\n<h3 id=\"17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？\"><a href=\"#17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？\" class=\"headerlink\" title=\"17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？\"></a>17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？</h3></blockquote>\n<p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 </p>\n<p>100M 左右的内存）就足够了。</p>\n<blockquote>\n<h3 id=\"18、生产上如何配置垃圾收集器的？\"><a href=\"#18、生产上如何配置垃圾收集器的？\" class=\"headerlink\" title=\"18、生产上如何配置垃圾收集器的？\"></a>18、生产上如何配置垃圾收集器的？</h3></blockquote>\n<table>\n<thead>\n<tr>\n<th><img src=\"/images/image-20220205181209799.png\" alt=\"image-20220205181209799\"></th>\n</tr>\n</thead>\n</table>\n<p>1、首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的2&#x2F;3（这是想</p>\n<p>给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。</p>\n<p>2、接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。</p>\n<p>3、再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。我会通过记录</p>\n<p>详细的GC日志，来找到这个瓶颈点，借用<strong>gceasy（重点）</strong><a href=\"https://gceasy.io/%E8%BF%99%E6%A0%B7%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%BE%88%E5%AE%B9%E6%98%93%E5%AE%9A%E4%BD%8D%E5%88%B0%E9%97%AE%E9%A2%98%E3%80%82%E4%B9%8B%E6%89%80%E4%BB%A5%E9%80%89%E6%8B%A9%E9%87%87%E7%94%A8%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%98%AF%E5%9B%A0\">https://gceasy.io/这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因</a></p>\n<p>为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。</p>\n<p><img src=\"/posts/c5e9cf91/image-20220216235212123.png\" alt=\"image-20220216235212123\"> </p>\n<h1 id=\"5-类加载器\"><a href=\"#5-类加载器\" class=\"headerlink\" title=\"5 类加载器\"></a>5 类加载器</h1><blockquote>\n<h3 id=\"19、什么是类加载器，类加载器有哪些？-高频\"><a href=\"#19、什么是类加载器，类加载器有哪些？-高频\" class=\"headerlink\" title=\"19、什么是类加载器，类加载器有哪些？(高频)\"></a>19、什么是类加载器，类加载器有哪些？(高频)</h3></blockquote>\n<p>类加载器的作用：负载将的class文件加载到java虚拟机中，并为之创建一个Class对象</p>\n<p>从Java虚拟机的角度来讲，只存在如下两种不同的类加载器：</p>\n<ol>\n<li>启动类加载器（Bootstrap ClassLoader）, 这个类加载器使用C++语言实现，是虚拟机自身的一部分</li>\n<li>其他类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类（java.lang.ClassLoader）</li>\n</ol>\n<p>从Java开发人员的角度来讲，类加载器还可以划分的更细致一下，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p>\n<ol>\n<li><p>启动类加载器（Bootstrap class loader）：它是虚拟机的内置类加载器，通过表示为null</p>\n</li>\n<li><p>平台类加载器（Platform class loader）  ：它是平台类加载器； 负责加载JDK中一些特殊的模块；</p>\n</li>\n<li><p>系统类加载器（System class loader）    ：它也被称为应用程序类加载器， 它负责加载用户类路径上所指定的类库，一般情况下这个就是程序中默</p>\n<p>认的类加载器</p>\n</li>\n</ol>\n<blockquote>\n<h3 id=\"20、Java的双亲委托机制是什么？-高频\"><a href=\"#20、Java的双亲委托机制是什么？-高频\" class=\"headerlink\" title=\"20、Java的双亲委托机制是什么？(高频)\"></a>20、Java的双亲委托机制是什么？(高频)</h3></blockquote>\n<p><strong>概述</strong></p>\n<p>我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的层次关系一般会如下图所</p>\n<p>示：</p>\n<img src=\"/posts/c5e9cf91/1577331614462.png\" alt=\"1577331614462\" style=\"zoom:33%;\">   \n\n<p>上图所展示的类加载器之间的这种层次关系，就称之为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该</p>\n<p>有自己的父类加载器。这里的类加载器的父子关系不是真正物理意义上的继承，而是逻辑上的继承。</p>\n<p><strong>工作过程</strong></p>\n<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个</p>\n<p>层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索</p>\n<p>返回中没有找到所需的类）时，子类加载器才会尝试自己去加载。</p>\n<h1 id=\"6-性能调优\"><a href=\"#6-性能调优\" class=\"headerlink\" title=\"6 性能调优\"></a>6 性能调优</h1><blockquote>\n<h3 id=\"21、调优命令有哪些？\"><a href=\"#21、调优命令有哪些？\" class=\"headerlink\" title=\"21、调优命令有哪些？\"></a>21、调优命令有哪些？</h3></blockquote>\n<p>1、<strong>jps</strong>，JVM Process Status Tool显示指定系统内所有的HotSpot虚拟机进程。</p>\n<p>2、<strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运</p>\n<p>行数据。</p>\n<p>查询帮助文档：jstat -options</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205192109645.png\" alt=\"image-20220205192109645\"></th>\n</tr>\n</thead>\n</table>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205192221590.png\" alt=\"image-20220205192221590\"></th>\n</tr>\n</thead>\n</table>\n<p>3、<strong>jmap</strong>，JVM Memory Map命令用于查看<strong>堆内存</strong>的分配情况以及生成heap dump文件 </p>\n<p>查询帮助文档：jmap -h</p>\n<p>示例1：jmap -heap 33193 查询堆内存的分配情况</p>\n<p>示例2：jmap -dump:format&#x3D;b,file&#x3D;thread-cup.log 33193</p>\n<p>4、<strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的</p>\n<p>分析结果后，可以在浏览器中查看</p>\n<p>查询帮助文档：</p>\n<p>jhat -h</p>\n<p>示例：jhat -J-Xmx512M thread-cup.log</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205193256668.png\" alt=\"image-20220205193256668\"></th>\n</tr>\n</thead>\n</table>\n<p>5、<strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。</p>\n<p>查看帮助文档：jstack -h</p>\n<p>示例：jstack -l 33193</p>\n<p>6、<strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p>\n<p>查看帮助文档：jinfo -h</p>\n<p>示例：jinfo -flags 33193</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/posts/c5e9cf91/image-20220205193604548.png\" alt=\"image-20220205193604548\"></th>\n</tr>\n</thead>\n</table>\n<blockquote>\n<h3 id=\"22、你知道哪些JVM性能调优参数？-高频\"><a href=\"#22、你知道哪些JVM性能调优参数？-高频\" class=\"headerlink\" title=\"22、你知道哪些JVM性能调优参数？(高频)\"></a>22、你知道哪些JVM性能调优参数？(高频)</h3></blockquote>\n<p>1、设定堆内存大小：</p>\n<p>​\t-Xms\t设置最小堆内存大小(不能小于1024K); \t-Xms 堆内存初始大小，可以通过jmap工具进行查看</p>\n<p>​\t-Xmx\t设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看</p>\n<p>2、设定新生代大小：</p>\n<p>​\t-XX:NewSize：新生代大小</p>\n<p>​\t-XX:NewRatio 新生代和老生代占比</p>\n<p>3、-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p>\n<p>4、设定垃圾回收器</p>\n<p>​\t年轻代用 -XX:+UseParNewGC </p>\n<p>​\t年老代用-XX:+UseConcMarkSweepGC</p>\n<blockquote>\n<h3 id=\"23、你用过哪些性能调优工具？-高频\"><a href=\"#23、你用过哪些性能调优工具？-高频\" class=\"headerlink\" title=\"23、你用过哪些性能调优工具？(高频)\"></a>23、你用过哪些性能调优工具？(高频)</h3></blockquote>\n<p>常用调优工具分为两类</p>\n<p>1、jdk自带监控工具</p>\n<ul>\n<li><p>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类</p>\n<p>等的监控</p>\n</li>\n<li><p>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</p>\n</li>\n</ul>\n<p>2、第三方</p>\n<ul>\n<li><p>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和</p>\n<p>减少内存消耗</p>\n</li>\n<li><p>GChisto，一款专业分析gc日志的工具</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"24、你都有哪些手段用来排查内存溢出？-高频\"><a href=\"#24、你都有哪些手段用来排查内存溢出？-高频\" class=\"headerlink\" title=\"24、你都有哪些手段用来排查内存溢出？(高频)\"></a>24、你都有哪些手段用来排查内存溢出？(高频)</h3></blockquote>\n<p>内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用<strong>jstat</strong>命令，发现Old区在一直增长。我使用</p>\n<p><strong>jmap</strong>命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学做缓</p>\n<p>存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 Guava Cache，并设置了弱引用，故障就消失了。</p>\n","categories":[],"tags":[]}